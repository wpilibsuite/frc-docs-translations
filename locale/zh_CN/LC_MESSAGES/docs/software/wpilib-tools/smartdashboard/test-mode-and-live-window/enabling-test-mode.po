# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, FIRST and other WPILib Contributors
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Team 5308 <team5308@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-02-10 04:13+0000\n"
"PO-Revision-Date: 2020-04-25 02:08+0000\n"
"Last-Translator: Team 5308 <team5308@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/wpilib/teams/109324/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:2
msgid "Enabling Test mode (LiveWindow)"
msgstr "激活测试模式 (LiveWindow)"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:4
msgid ""
"You may add code to your program to display values for your sensors and "
"actuators while the robot is in Test mode. This can be selected from the "
"Driver Station whenever the robot is not on the field. The code to display "
"these values is automatically generated by RobotBuilder and is described in "
"the next article. Test mode is designed to verify the correct operation of "
"the sensors and actuators on a robot. In addition it can be used for "
"obtaining setpoints from sensors such as potentiometers and for tuning PID "
"loops in your code."
msgstr ""
"当机器人处于测试模式时，您可以在程序中添加代码来显示传感器和执行器的数值。当机器人不在场上时，可以从操控站进行选择。显示这些值的代码由RobotBuilder自动生成，这将在下一篇文章中进行更详细的描述。测试模式的设计是为了验证传感器和执行器在机器人上的正确操作。此外，它还可以用于从诸如电位器的传感器上获取设定值，以及在代码中调整PID循环。"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:7
msgid "Setting Test mode with the Driver Station"
msgstr "在Driver Station中设置测试模式"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:10
msgid ""
"Enable Test Mode in the Driver Station by clicking on the \"Test\" button "
"and setting \"Enable\" on the robot. When doing this, the SmartDashboard "
"display will switch to test mode (LiveWindow) and will display the status of"
" any actuators and sensors used by your program."
msgstr ""
"在Driver Station中，点击 \"测试\" 按钮，在机器人上设置 \"启用\"，开启测试模式。当这样做时，智能仪表盘的显示将切换到测试模式 "
"(LiveWindow)，并将显示程序使用的所有执行器和传感器的状态。"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:13
msgid "Explicitly vs. implicit test mode display"
msgstr "显式与隐式测试模式显示"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:16
msgid ""
"All sensors and actuators will automatically be displayed on the "
"SmartDashboard in test mode and will be named using the object type (such as"
" Jaguar, Analog, Victor, etc.) with the module number and channel number "
"with which the object was created. In addition, the program can explicitly "
"add sensors and actuators to the test mode display, in which case "
"programmer-defined subsystem and object names can be specified making the "
"program clearer. This example illustrates explicitly defining those sensors "
"and actuators in the highlighted code."
msgstr ""
"所有传感器和执行器都将在测试模式下自动显示在智能仪表盘上，并使用对象类型 (如Jaguar、Analog、Victor等) "
"，创建对象的模块号和通道号命名。此外，该程序可以显式地在测试模式显示中添加传感器和执行器，在这种情况下，可以指定程序员定义的子系统和对象名称，使程序更加清晰。下面的这个栗子例子在高亮显示的代码中明确地定义了那些传感器和执行器。"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:19
msgid "Understanding what is displayed in Test mode"
msgstr "理解在测试模式下显示的内容"

#: ../../frc-docs/source/docs/software/wpilib-tools/smartdashboard/test-mode-and-live-window/enabling-test-mode.rst:22
msgid ""
"This is the output in the SmartDashboard display when the robot is placed "
"into test mode. In the display shown above the objects listed as Ungrouped "
"were implicitly created by WPILib when the corresponding objects were "
"created. These objects are contained in a subsystem group called "
"\"Ungrouped\" **(1)** and are named with the device type (Analog, Jaguar in "
"this case), and the module and channel numbers. The objects shown in the "
"\"SomeSubsystem\" **(2)** group are explicitly created by the programmer "
"from the code example in the previous section. These are named in the calls "
"to ``LiveWindow.addActuator()`` and ``LiveWindow.AddSensor()``. Explicitly "
"created sensors and actuators will be grouped by the specified subsystem."
msgstr ""
"这是机器人进入测试模式时智能仪表盘显示的输出。在上面的显示中，当创建相应的对象时，WPILib隐式地创建了未分组的对象。这些对象包含在一个名为 "
"\"Ungrouped\" **(1)** 的子系统组中，并以设备类型 (在本例中是模拟，Jaguar)，模块和通道号码来命名。在 "
"\"SomeSubsystem\" **(2)** 组中显示的对象是由程序员从上一节的代码示例中显式创建的。它们在对 "
"\"LiveWindow.addActuator()\" 和 \"LiveWindow.AddSensor()\" "
"的调用中被命名。而显式创建的传感器和驱动器则将按照其所属的子系统被分组。"
