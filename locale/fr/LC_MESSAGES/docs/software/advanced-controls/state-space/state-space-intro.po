# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, FIRST and other WPILib Contributors. This work is licensed under a Creative Commons Attribution 4.0 International License
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Kaitlyn Kenwell <redrield@gmail.com>, 2020
# Andre Theberge <atheberge2@videotron.ca>, 2022
# Marc Lalonde, 2023
# Regis Bekale <rbekale@robotiquefirstquebec.org>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2025\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-21 04:06+0000\n"
"PO-Revision-Date: 2020-10-04 04:16+0000\n"
"Last-Translator: Regis Bekale <rbekale@robotiquefirstquebec.org>, 2024\n"
"Language-Team: French (Canada) (https://app.transifex.com/wpilib/teams/109324/fr_CA/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr_CA\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:2
msgid "Introduction to State-Space Control"
msgstr "Introduction au Contrôle de l'Espace-État"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:7
msgid "From PID to Model-Based Control"
msgstr "Du PID au Contrôle à base d'un modèle"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:11
msgid ""
"Model-based control focuses on developing an accurate model of the "
":term:`system` (mechanism) we are trying to control. These models help "
"inform :term:`gains <gain>` picked for feedback controllers based on the "
"physical responses of the system, rather than an arbitrary proportional "
":term:`gain` derived through testing. This allows us not only to predict "
"ahead of time how a system will react, but also test our controllers without"
" a physical robot and save time debugging simple bugs."
msgstr ""
"Le contrôle à partir d'un modèle se concentre sur le développement d'un "
"modèle précis du :term:`système` (mécanisme) que nous essayons de contrôler."
" Ces modèles aident à affiner les :term:`gains <gain>` choisis pour les "
"commandes de rétroaction basées sur les réponses phyiques du système, au "
"lieu d'avoir un :term:`gain` proportionnel arbitraire dérivé de tests. Cela "
"nous permet non seulement de prédire comment un système va réagir, mais "
"aussi de tester nos contrôleurs sans avoir un robot physique en notre "
"possession et gagner du temps pendant le débogage des simples bogues ."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:15
msgid ""
"If you've used WPILib's feedforward classes for ``SimpleMotorFeedforward`` "
"or its sister classes, or used SysId to pick PID :term:`gains <gain>` for "
"you, you're already familiar with model-based control! The ``kv`` and ``ka``"
" :term:`gains <gain>` can be used to describe how a motor (or arm, or "
"drivetrain) will react to voltage. We can put these constants into standard "
"state-space notation using WPILib's ``LinearSystem``, something we will do "
"in a later article."
msgstr ""
"Si vous avez utilisé les classes feedforward de WPILib pour "
"``SimpleMotorFeedforward`` ou ses classes sœurs, ou utilisé SysId pour "
"choisir PID :term:`gains `<gain> pour vous, vous êtes déjà familiarisé avec "
"le contrôle basé sur un modèle ! Les ``kv`` et ``ka`` :term:`gains `<gain> "
"peuvent être utilisés pour décrire comment un moteur (ou un bras, ou une "
"transmission) réagira à la tension. Nous pouvons mettre ces constantes dans "
"la notation d'espace d'état standard en utilisant le ``LinearSystem`` de "
"WPILib, ce que nous ferons dans un article ultérieur."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:18
msgid "Vocabulary"
msgstr "Vocabulaire"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:20
msgid ""
"For the background vocabulary that will be used throughout this article, see"
" the :ref:`Glossary <docs/software/advanced-controls/controls-"
"glossary:Controls Glossary>`."
msgstr ""
"Pour le vocabulaire de base qui sera utilisé tout au long de cet article, "
"consultez le :ref:`Glossaire <docs/software/advanced-controls/controls-"
"glossary:Controls Glossary>`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:23
msgid "Introduction to Linear Algebra"
msgstr "Introduction à l'algèbre linéaire"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:28
msgid "What is State-Space?"
msgstr "Qu'est-ce que c'est que l'espace-état?"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:32
msgid "Two vectors in state space with their corresponding arrows."
msgstr ""
"Deux vecteurs dans l’espace d’état avec leurs flèches correspondantes."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:35
msgid ""
"In this image, the vectors representing states in state-space are arrows. "
"From now on these vectors will be represented simply by a point at the "
"vector's tip, but remember that the rest of the vector is still there."
msgstr ""
"Dans cette image, les vecteurs qui représentent les états dans l'espace-état"
" sont des flèches. À partir de maintenant ces vecteurs seront représentés "
"simplement par un point à la pointe du vecteur, mais souvenez-vous que le "
"reste du vecteur est toujours là. "

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:37
msgid ""
"In addition to the :term:`state`, :term:`inputs <input>` and :term:`outputs "
"<output>` are represented as vectors. Since the mapping from the current "
"states and inputs to the change in state is a system of equations, it’s "
"natural to write it in matrix form. This matrix equation can be written in "
"state-space notation."
msgstr ""
"En plus de :term:`l'état`, les :term:`entrées <input>` et :term:`sorties "
"<output>` sont representées aussi comme des vecteurs. Puisque la "
"correspondance des états actuels et les entrées au changement de l'état est "
"un système d'équations, c'est naturel d'écrire cette relation sous forme de "
"matrice. Cette équation matricielle peut être écrite dans notation d'espace-"
"état."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:40
msgid "What is State-Space Notation?"
msgstr "Qu'est-ce que c'est que la notation espace-état?"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:42
msgid ""
"State-space notation is a set of matrix equations which describe how a "
"system will evolve over time. These equations relate the change in state "
":math:`\\dot{\\mathbf{x}}`, and the :term:`output` :math:`\\mathbf{y}`, to "
"linear combinations of the current state vector :math:`\\mathbf{x}` and "
":term:`input` vector :math:`\\mathbf{u}`."
msgstr ""
"La notation espace-état est un ensemble d'équations matricielles qui décrit "
"comment un système évoluera dans le temps. Ces équations relient le "
"changement de l'état :math:`\\dot{\\mathbf{x}}`, et la :term:`sortie` "
":math:`\\mathbf{y}`, à des combinaisons linéaires du vecteur d'état actuel "
":math:`\\mathbf{x}` et le vecteur :term:`d’entrée` :math:`\\mathbf{u}`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:44
msgid ""
"State-space control can deal with continuous-time and discrete-time systems."
" In the continuous-time case, the rate of change of the system's state "
":math:`\\mathbf{\\dot{x}}` is expressed as a linear combination of the "
"current state :math:`\\mathbf{x}` and input :math:`\\mathbf{u}`."
msgstr ""
"Le contrôle de l'espace-état peut traiter des systèmes en temps continu ou "
"en temps discret. Dans le cas du temps continu, le taux de variation de "
"l'état du système :math:`\\mathbf{\\dot{x}}` est exprimé comme une "
"combinaison linéaire de l'état courant :math:`\\mathbf{x}` et de l'entrée "
":math:`\\mathbf{u}`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:46
msgid ""
"In contrast, discrete-time systems expresses the state of the system at our "
"next timestep :math:`\\mathbf{x}_{k+1}` based on the current state "
":math:`\\mathbf{x}_k` and input :math:`\\mathbf{u}_k`, where :math:`k` is "
"the current timestep and :math:`k+1` is the next timestep."
msgstr ""
"En revanche, les systèmes à temps discret expriment l'état du système à "
"notre prochain pas de temps :math:`\\mathbf{x}_{k+1}` basé sur l'état actuel"
" :math:`\\mathbf{x}_k` et l'entrée :math:`\\mathbf{u}_k`, où :math:`k` est "
"le pas de temps actuel et :math:`k+1` est le prochain pas de temps."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:48
msgid ""
"In both the continuous- and discrete-time forms, the :term:`output` vector "
":math:`\\mathbf{y}` is expressed as a linear combination of the current "
":term:`state` and :term:`input`. In many cases, the output is a subset of "
"the system's state, and has no contribution from the current input."
msgstr ""
"Dans les deux formes de temps continu et discret, le vecteur de "
":term:`sortie` :math:`\\mathbf{y}` est exprimé comme une combinaison "
"linéaire de :term:`l’état` actuel et de :term:`l’entrée`. Dans de nombreux "
"cas, la sortie est un sous-ensemble de l'état du système et n'a aucune "
"contribution de l'entrée actuelle."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:50
msgid ""
"When modeling systems, we first derive the continuous-time representation "
"because the equations of motion are naturally written as the rate of change "
"of a system's state as a linear combination of its current state and inputs."
" We convert this representation to discrete-time on the robot because we "
"update the system in discrete timesteps there instead of continuously."
msgstr ""
"Lors de la modélisation de systèmes, nous dérivons d'abord la représentation"
" en temps continu parce que les équations de mouvement sont naturellement "
"écrites comme le taux de changement de l'état d'un système comme une "
"combinaison linéaire de son état actuel et des entrées. Nous convertissons "
"cette représentation en temps discret sur le robot parce que nous mettons à "
"jour le système par intervalles de temps discrets au lieu de le faire en "
"continu."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:52
msgid ""
"The following two sets of equations are the standard form of continuous-time"
" and discrete-time state-space notation:"
msgstr ""
"Les deux ensembles d’équations suivantes constituent la forme standard de "
"notation espace-état en temps continu et en temps discret :"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:54
msgid ""
"\\text{Continuous: }\n"
"\\dot{\\mathbf{x}} &= \\mathbf{A}\\mathbf{x} + \\mathbf{B}\\mathbf{u} \\\\\n"
"\\mathbf{y} &= \\mathbf{C}\\mathbf{x} + \\mathbf{D}\\mathbf{u} \\\\\n"
"\\nonumber \\\\\n"
"\\text{Discrete: }\n"
"\\mathbf{x}_{k+1} &= \\mathbf{A}\\mathbf{x}_k + \\mathbf{B}\\mathbf{u}_k \\\\\n"
"\\mathbf{y}_k &= \\mathbf{C}\\mathbf{x}_k + \\mathbf{D}\\mathbf{u}_k\n"
"\n"
msgstr ""
"\\text{Continuous: }\n"
"\\dot{\\mathbf{x}} &= \\mathbf{A}\\mathbf{x} + \\mathbf{B}\\mathbf{u} \\\\\n"
"\\mathbf{y} &= \\mathbf{C}\\mathbf{x} + \\mathbf{D}\\mathbf{u} \\\\\n"
"\\nonumber \\\\\n"
"\\text{Discrete: }\n"
"\\mathbf{x}_{k+1} &= \\mathbf{A}\\mathbf{x}_k + \\mathbf{B}\\mathbf{u}_k \\\\\n"
"\\mathbf{y}_k &= \\mathbf{C}\\mathbf{x}_k + \\mathbf{D}\\mathbf{u}_k\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:63
msgid ""
"\\begin{array}{llll}\n"
"  \\mathbf{A} & \\text{system matrix}      & \\mathbf{x} & \\text{state vector} \\\\\n"
"  \\mathbf{B} & \\text{input matrix}       & \\mathbf{u} & \\text{input vector} \\\\\n"
"  \\mathbf{C} & \\text{output matrix}      & \\mathbf{y} & \\text{output vector} \\\\\n"
"  \\mathbf{D} & \\text{feedthrough matrix} &  &  \\\\\n"
"\\end{array}\n"
"\n"
msgstr ""
"\\begin{array}{llll}\n"
"\\mathbf{A} & \\text{system matrix} & \\mathbf{x} & \\text{state vector} \\\\\n"
"\\mathbf{B} & \\text{input matrix} & \\mathbf{u} & \\text{input vector} \\\\\n"
"\\mathbf{C} & \\text{output matrix} & \\mathbf{y} & \\text{output vector} \\\\\n"
"\\mathbf{D} & \\text{feedthrough matrix} & & \\\\\n"
"\\end{array}\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:71
msgid ""
"A continuous-time state-space system can be converted into a discrete-time "
"system through a process called discretization."
msgstr ""
"Un système d'espace d'état à temps continu peut être converti en un système "
"à temps discret grâce à un processus appelé discrétisation."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:73
msgid ""
"In the discrete-time form, the system's state is held constant between "
"updates. This means that we can only react to disturbances as quickly as our"
" state estimate is updated. Updating our estimate more quickly can help "
"improve performance, up to a point. WPILib's ``Notifier`` class can be used "
"if updates faster than the main robot loop are desired."
msgstr ""
"Dans la forme à temps discret, l'état du système est maintenu constant entre"
" les mises à jour. Cela signifie que nous ne pouvons réagir aux "
"perturbations aussi rapidement que notre estimation d'état est mise à jour. "
"Mettre à jour notre estimation plus rapidement peut aider à améliorer les "
"performances, jusqu'à un certain point. La classe ``Notifier`` de WPILib "
"peut être utilisée si des mises à jour plus rapides que la boucle principale"
" du robot sont souhaitées."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:75
msgid ""
"While a system's continuous-time and discrete-time matrices A, B, C, and D "
"have the same names, they are not equivalent. The continuous-time matrices "
"describes the rate of change of the state, :math:`\\mathbf{x}`, while the "
"discrete-time matrices describe the system's state at the next timestep as a"
" function of the current state and input."
msgstr ""
"Bien que les matrices en temps continu et en temps discret A, B, C et D d'un"
" système portent les mêmes noms, elles ne sont pas équivalentes. Les "
"matrices à temps continu décrivent le taux de changement de l'état,  "
":math:`\\mathbf{x}`, tandis que les matrices à temps discret décrivent "
"l'état du système au prochain intervalle de temps en fonction de l'état "
"actuel et de l'entrée."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:77
msgid ""
"WPILib's LinearSystem takes continuous-time system matrices, and converts "
"them internally to the discrete-time form where necessary."
msgstr ""
"LinearSystem de WPILib prend des matrices système en temps continu et les "
"convertit en interne en forme de temps discret si nécessaire."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:84
msgid ""
"We can convert this equation to state-space notation. We can create a system"
" with one state (velocity), one :term:`input` (voltage), and one "
":term:`output` (velocity). Recalling that the first derivative of velocity "
"is acceleration, we can write our equation as follows, replacing velocity "
"with :math:`\\mathbf{x}`, acceleration with :math:`\\mathbf{\\dot{x}}`, and "
"voltage :math:`\\mathbf{V}` with :math:`\\mathbf{u}`:"
msgstr ""
"Nous pouvons convertir cette équation en notation d'espace d'états. Nous "
"pouvons créer un système avec un état (vitesse), une :term:`entrée` "
"(tension), et une :term:`sortie` (vitesse). En rappelant que la première "
"dérivée de la vitesse est l'accélération, nous pouvons écrire notre équation"
" comme suit, en remplaçant la vitesse par :math:`\\mathbf{x}`, "
"l'accélération par :math:`\\mathbf{\\dot{x}}`, et la tension "
":math:`\\mathbf{V}` par :math:`\\mathbf{u}`:"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:97
msgid "Visualizing State-Space Responses: Phase Portrait"
msgstr "Visualisation des réponses de l'espace d'état: portrait de phase"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:101
msgid ""
"To trace a potential trajectory that a system could take through state-"
"space, choose a point to start at and follow the arrows around. In this "
"example, we might start at :math:`[-2, 0]`. From there, the velocity "
"increases as we swing through vertical and starts to decrease until we reach"
" the opposite extreme of the swing. This cycle of spinning about the origin "
"repeats indefinitely."
msgstr ""
"Pour tracer une trajectoire potentielle qu'un système pourrait emprunter à "
"travers l'espace d'états, choisissez un point de départ et suivez les "
"flèches. Dans cet exemple, nous pourrions commencer par :math:`[-2, 0]`. À "
"partir de là, la vitesse augmente à mesure que nous nous balançons "
"verticalement et commence à diminuer jusqu'à ce que nous atteignions "
"l'extrême opposé du balancement. Ce cycle de rotation autour de l'origine se"
" répète indéfiniment."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:103
msgid "Pendulum Phase Plot with arrows all around going roughly in a circle."
msgstr ""
"Diagramme de phase pendulaire avec des flèches tout autour allant à peu près"
" dans un cercle."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:106
msgid ""
"Note that near the edges of the phase portrait, the X axis wraps around as a"
" rotation of :math:`\\pi` radians counter clockwise and a rotation of "
":math:`\\pi` radians clockwise will end at the same point."
msgstr ""
"Notez que près des bords du portrait de phase, l'axe X s'enroule comme une "
"rotation de :math:`\\pi` radians dans le sens antihoraire et une rotation de"
" :math:`\\pi` radians dans le sens horaire se terminera au même point."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:111
msgid "Visualizing Feedforward"
msgstr "Visualiser le Feedforward"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:113
msgid ""
"This phase portrait shows the \"open loop\" responses of the system -- that "
"is, how it will react if we were to let the state evolve naturally. If we "
"want to, say, balance the pendulum horizontal (at :math:`(\\frac{\\pi}{2}, "
"0)` in state space), we would need to somehow apply a control :term:`input` "
"to counteract the open loop tendency of the pendulum to swing downward. This"
" is what feedforward is trying to do -- make it so that our phase portrait "
"will have an equilibrium at the :term:`reference` position (or setpoint) in "
"state-space."
msgstr ""
"Ce portrait de phase montre les réponses \"en boucle ouverte\" du système - "
"c'est-à-dire comment il réagira si nous laissons l'état évoluer "
"naturellement. Si nous voulons, par exemple, équilibrer le pendule "
"horizontal (à :math:`(\\frac{\\pi}{2}, 0)` dans l'espace d'états), nous "
"aurions besoin d'appliquer une commande :term:`d’entrée` pour contrer la "
"tendance en boucle ouverte du pendule à basculer vers le bas. C'est ce que "
"la commande prédictive essaie de faire - faire en sorte que notre portrait "
"de phase ait un équilibre à la position de :term:`référence` (ou point de "
"consigne) dans l'espace d'états."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:117
msgid "Pendulum phase plot with equilibrium at (pi/2, 0)."
msgstr "Diagramme de phase pendulaire avec équilibre à (pi/2, 0)."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:121
msgid "Feedback Control"
msgstr "Commande de rétroaction"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:123
msgid ""
"In the case of a DC motor, with just a mathematical model and knowledge of "
"all current states of the system (i.e., angular velocity), we can predict "
"all future states given the future voltage inputs. But if the system is "
"disturbed in any way that isn’t modeled by our equations, like a load or "
"unexpected friction, the angular velocity of the motor will deviate from the"
" model over time. To combat this, we can give the motor corrective commands "
"using a feedback controller."
msgstr ""
"Dans le cas d'un moteur à courant continu, avec juste un modèle mathématique"
" et une connaissance de tous les états actuels du système (c'est-à-dire la "
"vitesse angulaire), nous pouvons prédire tous les états futurs compte tenu "
"des futures entrées de tension. Mais si le système est perturbé d'une "
"manière qui n'est pas modélisée par nos équations, comme une charge ou un "
"frottement inattendu, la vitesse angulaire du moteur s'écartera du modèle au"
" fil du temps. Pour lutter contre cela, nous pouvons donner au moteur des "
"commandes correctives à l'aide d'un contrôleur de rétroaction."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:125
msgid ""
"A PID controller is a form of feedback control. State-space control often "
"uses the following :term:`control law`, where :math:`\\mathbf{K}` is some "
"controller :term:`gain` matrix, :math:`\\mathbf{r}` is the :term:`reference`"
" state, and :math:`\\mathbf{x}` is the current state in state-space. The "
"difference between these two vectors, :math:`\\mathbf{r-x}`, is the "
":term:`error`."
msgstr ""
"Un contrôleur PID est une forme de commande de rétroaction. Le contrôle de "
"l'espace d'états utilise souvent la :term:`loi de commande` suivante, où "
":math:`\\mathbf{K}` est la matrice de :term:`gain` d'une commande, "
":math:`\\mathbf{r}` est l'état de :term:`référence`, et :math:`\\mathbf{x}` "
"est l'état actuel dans l'espace d'états. La différence entre ces deux "
"vecteurs, :math:`\\mathbf{r-x}`, correspond à :term:`l’erreur`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:127
msgid ""
"\\mathbf{u} = \\mathbf{K(r - x)}\n"
"\n"
msgstr "\\mathbf{u} = \\mathbf{K(r - x)}\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:130
msgid ""
"This :term:`control law` is a proportional controller for each state of our "
"system. Proportional controllers create software-defined springs that pull "
"our system's state toward our reference state in state-space. In the case "
"that the system being controlled has position and velocity states, the "
":term:`control law` above will behave as a PD controller, which also tries "
"to drive position and velocity error to zero."
msgstr ""
"Cette :term:`loi de commande` correspond à un contrôleur proportionnel pour "
"chaque état de notre système. Les contrôleurs proportionnels créent des "
"\"ressorts\" définis par logiciel qui tirent l'état de notre système vers "
"notre état de référence dans l'espace d'états. Dans le cas où le système "
"commandé a des états de position et de vitesse, la :term:`loi de commande` "
"ci-dessus se comportera comme un contrôleur PD, qui essaie également de "
"ramener l'erreur de position et de vitesse à zéro."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:132
msgid ""
"Let's show an example of this control law in action. We'll use the pendulum "
"system from above, where the swinging pendulum circled the origin in state-"
"space. The case where :math:`\\mathbf{K}` is the zero matrix (a matrix with "
"all zeros) would be like picking P and D gains of zero -- no control "
":term:`input` would be applied, and the phase portrait would look identical "
"to the one above."
msgstr ""
"Montrons un exemple de cette loi de commande en action. Nous utiliserons le "
"système de pendule décrit plus haut, où le pendule oscillant encercle "
"l'origine dans l'espace d'états. Le cas où :math:`\\mathbf {K}` est la "
"matrice nulle (une matrice dont tous les éléments sont des zéros) équivaut à"
" choisir des gains P et D nuls - aucune :term:`entrée` de commande serait "
"appliquée, et le diagramme de phase serait identique à celui présenté ci-"
"dessus."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:134
msgid ""
"To add some feedback, we arbitrarily pick a :math:`\\mathbf{K}` of [2, 2], "
"where our :term:`input` to the pendulum is angular acceleration. This K "
"would mean that for every radian of position :term:`error`, the angular "
"acceleration would be 2 radians per second squared; similarly, we accelerate"
" by 2 radians per second squared for every radian per second of "
":term:`error`. Try following an arrow from somewhere in state-space inwards "
"-- no matter the initial conditions, the state will settle at the "
":term:`reference` rather than circle endlessly with pure feedforward."
msgstr ""
"Pour ajouter une rétroaction, nous choisissons arbitrairement un "
":math:`\\mathbf {K}` de [2, 2], où notre :term:`entrée` du pendule est une "
"accélération angulaire. Ce K signifie que pour chaque :term:`erreur` de "
"position de 1 radian, l'accélération angulaire serait de 2 radians par "
"seconde au carré; en d'autres mots, nous accélérons de 2 radians par seconde"
" au carré pour chaque radian par seconde term:`d’erreur`. Essayez de suivre "
"une flèche en provenance de quelque part dans l'espace d'états vers "
"l'intérieur - quelles que soient les conditions initiales, l'état convergera"
" vers la :term:`référence` plutôt que de tourner sans fin comme ce serait le"
" cas avec une commande avec rétroaction pure."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:136
msgid "Closed loop pendulum phase plot with reference at (pi/2, 0)."
msgstr ""
"Diagramme de phase pendulaire en boucle fermée avec référence à (pi/2, 0)."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:139
msgid ""
"But how can we choose an optimal :term:`gain` matrix K for our system? While"
" we can manually choose :term:`gains <gain>` and simulate the system "
"response or tune it on-robot like a PID controller, modern control theory "
"has a better answer: the Linear-Quadratic Regulator (LQR)."
msgstr ""
"Mais comment choisir une matrice de :term:`gain` K optimale pour notre "
"système? Alors que nous pouvons choisir manuellement les :term:`gains "
"<gain>` et simuler la réponse du système ou l'ajuster sur le robot comme un "
"contrôleur PID, la théorie de commande moderne a une meilleure réponse: le "
"régulateur linéaire-quadratique (LQR)."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:142
msgid "The Linear-Quadratic Regulator"
msgstr "Le régulateur linéaire-quadratique"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:144
msgid ""
"Because model-based control means that we can predict the future states of a"
" system given an initial condition and future control inputs, we can pick a "
"mathematically optimal :term:`gain` matrix :math:`\\mathbf{K}`. To do this, "
"we first have to define what a \"good\" or \"bad\" :math:`\\mathbf{K}` would"
" look like. We do this by summing the square of error and control input over"
" time, which gives us a number representing how \"bad\" our control law will"
" be. If we minimize this sum, we will have arrived at the optimal control "
"law."
msgstr ""
"Comme la commande basée sur un modèle signifie que nous pouvons prédire les "
"états futurs d'un système étant données une condition initiale et des "
"entrées de commande futures, nous pouvons choisir une matrice de "
":term:`gain` math:`\\mathbf {K}` mathématiquement optimale. À cette fin, "
"nous devons d'abord définir à quoi correspondrait une \"bonne\" ou "
"\"mauvaise\" matrice :math:`\\mathbf{K}`. Pour ce faire, nous additionnons "
"dans le temps le carré de l'erreur et de l'entrée de commande, ceci nous "
"donne un nombre représentant à quel point notre loi de contrôle sera "
"\"mauvaise\". Si nous minimisons cette somme, nous arrivons à la loi de "
"commande optimale recherchée."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:147
msgid "LQR: Definition"
msgstr "LQR: Définition"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:156
msgid ""
"LQR design's :math:`\\mathbf{Q}` and :math:`\\mathbf{R}` matrices don't need"
" discretization, but the :math:`\\mathbf{K}` calculated for continuous-time "
"and discrete time :term:`systems <system>` will be different."
msgstr ""
"Les matrices :math:`\\mathbf{Q}` et :math:`\\mathbf{R}` d'un modèle n'ont "
"pas besoin de discrétisation, mais les matrices :math:`\\mathbf{K}` "
"calculées pour les :term:`systèmes<system>` en temps continu et en temps "
"discret seront différentes."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:159
msgid "LQR: tuning"
msgstr "LQR: réglage"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:161
msgid ""
"Like PID controllers can be tuned by adjusting their gains, we also want to "
"change how our control law balances our error and input. For example, a "
"spaceship might want to minimize the fuel it expends to reach a given "
"reference, while a high-speed robotic arm might need to react quickly to "
"disturbances."
msgstr ""
"Tout comme les contrôleurs PID peuvent être réglés en ajustant leurs gains, "
"nous voulons également changer la façon dont notre loi de commande équilibre"
" notre erreur et notre entrée. Par exemple, un vaisseau spatial peut vouloir"
" minimiser le carburant qu'il dépense pour atteindre une référence donnée, "
"tandis qu'un bras robotique à grande vitesse peut avoir besoin de réagir "
"rapidement aux perturbations."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:163
msgid ""
"We can weight error and control effort in our LQR with :math:`\\mathbf{Q}` "
"and :math:`\\mathbf{R}` matrices. In our cost function (which describes how "
"\"bad\" our control law will perform), :math:`\\mathbf{Q}` and "
":math:`\\mathbf{R}` weight our error and control input relative to each "
"other. In the spaceship example from above, we might use a "
":math:`\\mathbf{Q}` with relatively small numbers to show that we don't want"
" to highly penalize error, while our :math:`\\mathbf{R}` might be large to "
"show that expending fuel is undesirable."
msgstr ""
"Nous pouvons pondérer l'erreur et contrôler l'effort dans notre modèle LQR "
"avec les matrices :math:`\\mathbf{Q}` et :math:`\\mathbf{R}`. Dans notre "
"fonction de coût (qui décrit la \"mauvaise\" performance de notre loi de "
"commande), :math:`\\mathbf{Q}` et :math:`\\mathbf{R}` pondèrent notre erreur"
" et les entrées de commande l'une par rapport à l'autre. Dans l'exemple de "
"vaisseau spatial ci-dessus, nous pourrions utiliser une matrice  "
":math:`\\mathbf{Q}` avec des valeurs relativement faibles pour montrer que "
"nous ne voulons pas pénaliser fortement l'erreur, tandis que notre "
":math:`\\mathbf{R}` pourrait être élevée pour montrer que dépenser du "
"carburant n'est pas souhaitable."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:165
msgid ""
"With WPILib, the LQR class takes a vector of desired maximum state "
"excursions and control efforts and converts them internally to full Q and R "
"matrices with Bryson's rule. We often use lowercase :math:`\\mathbf{q}` and "
":math:`\\mathbf{r}` to refer to these vectors, and :math:`\\mathbf{Q}` and "
":math:`\\mathbf{R}` to refer to the matrices."
msgstr ""
"Avec WPILib, la classe LQR prend un vecteur d'excursions d'état maximum "
"souhaitées et d'efforts de contrôle et les convertit en interne en matrices "
"Q et R complètes avec la règle de Bryson. Nous utilisons souvent des "
"minuscules :math:`\\mathbf{q}` et :math:`\\mathbf{r}` pour faire référence à"
" ces vecteurs, et :math:`\\mathbf{Q}` et :math:`\\mathbf{R}` pour faire "
"référence aux matrices."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:167
msgid ""
"Increasing the :math:`\\mathbf{q}` elements would make the LQR less heavily "
"weight large errors, and the resulting :term:`control law` will behave more "
"conservatively. This has a similar effect to penalizing :term:`control "
"effort` more heavily by decreasing :math:`\\mathbf{r}`\\'s elements."
msgstr ""
" L’augmentation des éléments :math:`\\mathbf{q}` rendrait le LQR moins lourd"
" poids les erreurs élevées, et la :term:`loi de commande` résultaante se "
"comportera de manière plus conservatrice. Cela a un effet similaire à la "
"pénalisation de :term:`l’effort de commande` plus fortement en diminuant les"
" éléments :math:`\\mathbf{r}`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:169
msgid ""
"Similarly, decreasing the :math:`\\mathbf{q}` elements would make the LQR "
"penalize large errors more heavily, and the resulting :term:`control law` "
"will behave more aggressively. This has a similar effect to penalizing "
":term:`control effort` less heavily by increasing :math:`\\mathbf{r}` "
"elements."
msgstr ""
" De même, la diminution des éléments :math:`\\mathbf{q}` ferait que le LQR "
"pénalise plus lourdement les erreurs élevées, et la :term:` loi de commande`"
" qui en résulterait se comporterait de manière plus agressive. Cela a un "
"effet similaire à pénaliser moins lourdement :term:`l’effort de commande` en"
" augmentant les éléments :math:`\\mathbf{r}`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:171
msgid ""
"For example, we might use the following Q and R for an elevator system with "
"position and velocity states."
msgstr ""
"Par exemple, nous pourrions utiliser les Q et R suivants pour un système "
"d'élévateur avec des états de position et de vitesse."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:221
msgid "LQR: example application"
msgstr "LQR: exemple d'application"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:228
msgid ""
"We arbitrarily choose a desired state excursion (maximum error) of :math:`q "
"= [0.1\\ \\text{rad/sec}]`, and an :math:`\\mathbf{r}` of :math:`[12\\ "
"\\text{volts}]`. After discretization with a timestep of 20ms, we find a "
":term:`gain` of :math:`\\mathbf{K} = ~81`. This K :term:`gain` acts as the "
"proportional component of a PID loop on flywheel's velocity."
msgstr ""
"Nous choisissons arbitrairement une excursion d'état désirée (erreur "
"maximale) de :math:`q = [0.1\\ \\text{rad/sec}]`, et un :math:`\\mathbf{r}` "
"de :math:`[12\\ \\text{volts}]`. Après discrétisation avec un pas de temps "
"de 20ms, on trouve un :term:`gain` de :math:`\\mathbf{K} = ~81`. Ce "
":term:`gain` K agit comme la composante proportionnelle d'une boucle PID sur"
" la vitesse du volant d'inertie."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:232
msgid ""
"The following graph shows the flywheel's angular velocity and applied "
"voltage over time with two different :term:`gain`\\s. We can see how a "
"higher :term:`gain` will make the system reach the reference more quickly "
"(at t = 0.8 seconds), while keeping our motor saturated at 12V for longer. "
"This is exactly the same as increasing the P gain of a PID controller by a "
"factor of ~8x."
msgstr ""
"Le graphique suivant montre la vitesse angulaire du volant d'inertie et la "
"tension appliquée au fil du temps avec deux :term:`gain`\\s. Nous pouvons "
"voir comment un :term:`gain` plus élevé permettra au système d'atteindre la "
"référence plus rapidement (à t = 0.8 seconde), tout en maintenant notre "
"moteur saturé à 12V plus longtemps. C'est exactement la même chose que "
"d'augmenter le gain P d'un régulateur PID d'un facteur ~ 8x."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:234
msgid "Flywheel velocity and voltage over time."
msgstr "Vitesse et tension du volant d’inertie au fil du temps."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:238
msgid "LQR and Measurement Latency Compensation"
msgstr "LQR et compensation de latence de mesure"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:240
msgid ""
"Oftentimes, our sensors have a delay associated with their measurements. For"
" example the SPARK MAX motor controller over CAN can have up to 30ms of "
"delay associated with velocity measurements."
msgstr ""
"Souvent, nos capteurs ont un retard associé à leurs mesures. Par exemple, le"
" contrôleur de moteur SPARK MAX sur CAN peut avoir jusqu'à 30 ms de retard "
"associé aux mesures de vitesse."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:242
msgid ""
"This lag means that our feedback controller will be generating voltage "
"commands based on state estimates from the past. This often has the effect "
"of introducing instability and oscillations into our system, as shown in the"
" graph below."
msgstr ""
"Ce décalage signifie que notre contrôleur de rétroaction générera des "
"commandes de tension basées sur des estimations d'état du passé. Cela a "
"souvent pour effet d'introduire de l'instabilité et des oscillations dans "
"notre système, comme le montre le graphique ci-dessous."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:244
msgid ""
"However, we can model our controller to control where the system's "
":term:`state` is delayed into the future. This will reduce the LQR's "
":term:`gain` matrix :math:`\\mathbf{K}`, trading off controller performance "
"for stability. The below formula, which adjusts the :term:`gain` matrix to "
"account for delay, is also used in system identification."
msgstr ""
"Cependant, nous pouvons modéliser notre contrôleur pour contrôler où le "
":term:`state` du système est retardé dans le futur. Cela réduira la matrice "
":term:`gain` du LQR :math:`\\mathbf{K}`, échangeant les performances du "
"contrôleur contre la stabilité. La formule ci-dessous, qui ajuste la matrice"
" :term:`gain` pour tenir compte du retard, est également utilisée dans "
"l'identification du système."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:246
msgid ""
"\\mathbf{K_{compensated}} = \\mathbf{K} \\cdot \\left(\\mathbf{A} - \\mathbf{BK}\\right)^{\\text{delay} / dt}\n"
"\n"
msgstr ""
"\\mathbf{K_{compensated}} = \\mathbf{K} \\cdot \\left(\\mathbf{A} - "
"\\mathbf{BK}\\right)^{\\text{delay} / dt}\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:249
msgid ""
"Multiplying :math:`\\mathbf{K}` by :math:`\\mathbf{A} - \\mathbf{BK}` "
"essentially advances the gains by one timestep. In this case, we multiply by"
" :math:`\\left(\\mathbf{A} - \\mathbf{BK}\\right)^{\\text{delay} / dt}` to "
"advance the gains by measurement's delay."
msgstr ""
"Multiplier :math:`\\mathbf{K}` par :math:`\\mathbf{A} - \\mathbf{BK}` avance"
" essentiellement les gains d'un pas de temps. Dans ce cas, on multiplie par "
":math:`\\left(\\mathbf{A} - \\mathbf{BK}\\right)^{\\text{delay} / dt}` pour "
"avancer les gains par le retard de la mesure."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:251
msgid "Flywheel velocity and voltage with dt=5.0ms and a 10.0ms delay."
msgstr ""
"Vitesse et tension du volant d’inertie avec dt = 5,0ms et un retard de "
"10,0ms."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:254
msgid ""
"This can have the effect of reducing :math:`\\mathbf{K}` to zero, "
"effectively disabling feedback control."
msgstr ""
"Cela peut avoir pour effet de réduire :math:`\\mathbf{K}` à zéro, "
"désactivant ainsi la commande de rétroaction."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:256
msgid ""
"The SPARK MAX motor controller uses a 40-tap FIR filter with a delay of "
"19.5ms, and status frames are by default sent every 20ms."
msgstr ""
"Le contrôleur de moteur SPARK MAX utilise un filtre à réponse impulsionnelle"
" finie ou RIF à 40 prises avec un retard de 19.5 ms, et les trames d’état "
"sont envoyées par défaut tous les 20ms."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:258
msgid ""
"The code below shows how to adjust the LQR controller's K gain for sensor "
"input delays:"
msgstr ""
"Le code ci-dessous montre comment régler le gain K du contrôleur LQR pour "
"les délais d'entrée du capteur:"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:286
msgid "Linearization"
msgstr "Linéarisation"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:288
msgid ""
"Linearization is a tool used to approximate nonlinear functions and state-"
"space systems using linear ones. In two-dimensional space, linear functions "
"are straight lines while nonlinear functions curve. A common example of a "
"nonlinear function and its corresponding linear approximation is "
":math:`y=\\sin{x}`. This function can be approximated by :math:`y=x` near "
"zero. This approximation is accurate while near :math:`x=0`, but looses "
"accuracy as we stray further from the linearization point. For example, the "
"approximation :math:`\\sin{x} \\approx x` is accurate to within 0.02 within "
"0.5 radians of :math:`y = 0`, but quickly loses accuracy past that. In the "
"following picture, we see :math:`y =\\sin{x}`, :math:`y=x` and the "
"difference between the approximation and the true value of :math:`\\sin{x}` "
"at :math:`x`."
msgstr ""
"La linéarisation est un outil utilisé pour approximer les fonctions non "
"linéaires et les systèmes d'espace d'états en faisant usage de systèmes "
"linéaires. Dans l'espace bidimensionnel, les fonctions linéaires sont des "
"lignes droites tandis que les fonctions non linéaires sont courbes. Un "
"exemple courant de fonction non linéaire et de son approximation linéaire "
"correspondante est: :math:`y=\\sin{x}`. Cette fonction peut être approximée "
"par :math:`y=x` près de zéro. Cette approximation est précise lorsqu'elle "
"est proche de :math:`x=0`, mais perd de la précision lorsque nous nous "
"éloignons du point de linéarisation. Par exemple, l'approximation "
":math:`\\sin{x} \\approx x` est précise à 0.02 près de 0.5 radians de "
":math:`y = 0`, mais perd rapidement sa précision au-delà. Dans l'image "
"suivante, nous voyons :math:`y =\\sin{x}`, :math:`y=x` et la différence "
"entre l'approximation et la vraie valeur de :math:`\\sin{x}` à :math:`x`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:290
msgid "Three plots showing sin(x), x, and sin(x) - x."
msgstr "Trois tracés montrant sin(x), x et sin(x) - x."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:293
msgid ""
"We can also linearize state-space systems with nonlinear :term:`dynamics`. "
"We do this by picking a point :math:`\\mathbf{x}` in state-space and using "
"this as the input to our nonlinear functions. Like in the above example, "
"this works well for states near the point about which the system was "
"linearized, but can quickly diverge further from that state."
msgstr ""
"Nous pouvons également linéariser des systèmes d'espace d'états en faisant "
"appel à une :term:`dynamique` non-linéaire. Pour ce faire, choisissons un "
"point :math:`\\mathbf{x}` dans l'espace d'états et en utilisons-le comme "
"entrée de nos fonctions non linéaires. Comme dans l'exemple ci-dessus, cela "
"fonctionne bien pour les états proches du point sur lequel le système a été "
"linéarisé, mais peut rapidement diverger davantage de cet état."
