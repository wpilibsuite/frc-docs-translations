# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, FIRST and other WPILib Contributors
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 楚涵 张 <zhangchuhan1210@126.com>, 2020
# Tianrui Wu <tw2789@columbia.edu>, 2020
# Michael Zhao <haitong1110@126.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-21 04:41+0000\n"
"PO-Revision-Date: 2020-04-25 02:05+0000\n"
"Last-Translator: Michael Zhao <haitong1110@126.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/wpilib/teams/109324/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:4
msgid "2017 Vision Examples"
msgstr "2017视觉程序示例"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:7
msgid "LabVIEW"
msgstr "LabVIEW"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:9
msgid ""
"The 2017 LabVIEW Vision Example is included with the other LabVIEW examples."
" From the Splash screen, click Support->Find FRC\\ |reg| Examples or from "
"any other LabVIEW window, click Help->Find Examples and locate the Vision "
"folder to find the 2017 Vision Example. The example images are bundled with "
"the example."
msgstr ""
"其他LabVIEW范例随附2017 LabVIEW Vision范例。在启动屏幕上，单击支持->查找FRC \\ | reg "
"|。示例或在任何其他LabVIEW窗口中，单击帮助->查找示例，然后找到Vision文件夹以查找2017 Vision示例。示例图像与示例捆绑在一起。"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:12
msgid "C++/Java"
msgstr "C++/Java"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:14
msgid ""
"We have provided a GRIP project and the description below, as well as the "
"example images, bundled into a ZIP that `can be found on TeamForge "
"<https://usfirst.collab.net/sf/frs/do/viewRelease/projects.wpilib/frs.sample_programs.2017_c_java_vision_sample>`_."
msgstr ""
"我们提供打包成ZIP文件的一个GRIP项目，其中包括项目描述以及示例图像。可以在TeamForge "
"<https://usfirst.collab.net/sf/frs/do/viewRelease/projects.wpilib/frs.sample_programs.2017_c_java_vision_sample>中找到ZIP文件。"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:16
msgid ""
"See :ref:`docs/software/vision-processing/grip/using-generated-code-in-a"
"-robot-program:Using Generated Code in a Robot Program` for details about "
"integrating GRIP generated code in your robot program."
msgstr ""
"参见:ref: 'docs/software/vision-processing/grip/ use -generated-code in-a- "
"Robot - Program:Using Generated Code in a Robot - Program "
"'，了解如何在机器人程序中整合GRIP生成代码的详细信息。"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:18
msgid ""
"The code generated by the included GRIP project will find OpenCV contours "
"for green particles in images like the ones included in the Vision Images "
"folder of this ZIP. From there you may wish to further process these "
"contours to assess if they are the target. To do this:"
msgstr ""
"内置的GRIP项目生成的代码将使用OpenCV在图像中找到绿色物体的轮廓，就如此ZIP的Vision "
"images文件夹中所包含的图像那样。之后，您可能希望进一步处理这些轮廓，以评估它们是否是目标。为此： "

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:20
msgid ""
"Use the boundingRect method to draw bounding rectangles around the contours"
msgstr "使用boundingRect方法在边缘轮廓周围绘制外接矩形"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:21
msgid ""
"The LabVIEW example code calculates 5 separate ratios for the target. Each "
"of these ratios should nominally equal 1.0. To do this, it sorts the "
"contours by size, then starting with the largest, calculates these values "
"for every possible pair of contours that may be the target, and stops if it "
"finds a target or returns the best pair it found."
msgstr ""
"LabVIEW示例代码为此目标计算5个单独的比率。每个比率名义上应该等于1.0。为此，它按大小对轮廓进行排序，然后从最大的开始，对每一对可能是目标的轮廓进行值计算，并在找到目标或返回它找到的最佳对时停止。"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:23
msgid ""
"In the formulas below, each letter refers to a coordinate of the bounding "
"rect (H = Height, L = Left, T = Top, B = Bottom, W = Width) and the numeric "
"subscript refers to the contour number (1 is the largest contour, 2 is the "
"second largest, etc)."
msgstr ""
"下面公式中，每个字母代表外接矩形的一个指标(H =高，L=左，T=上，B=下，W=宽)，数字下标为等高值（1为最大轮廓，2为第二大轮廓，以此类推）。"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:25
msgid "Top height should be 40% of total height (4 in / 10 in):"
msgstr "最大高度应占总高度的40%（4英寸/ 10英寸）："

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:27
msgid ""
"\\textit{Group Height} = \\frac{H_1}{0.4 (B_2 - T_1)}\n"
"\n"
msgstr "\\textit{Group Height} = \\frac{H_1}{0.4 (B_2 - T_1)}\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:29
msgid ""
"Top of bottom stripe to top of top stripe should be 60% of total height (6 "
"in / 10 in):"
msgstr "底部边顶部至顶部边顶部应为总高度的60%（6 英寸/10 英寸）："

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:31
msgid ""
"\\textit{dTop} = \\frac{T_2 - T_1}{0.6 (B_2 - T_1)}\n"
"\n"
msgstr "\\textit{dTop} = \\frac{T_2 - T_1}{0.6 (B_2 - T_1)}\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:33
msgid ""
"The distance between the left edge of contour 1 and the left edge of contour"
" 2 should be small relative to the width of the 1st contour; then we add 1 "
"to make the ratio centered on 1:"
msgstr "轮廓1左缘到轮廓2左缘的距离相对于第一个轮廓的宽度应较小;然后我们加1以使比值达到1："

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:35
msgid ""
"\\textit{LEdge} = \\frac{L_1 - L_2}{W_1} + 1\n"
"\n"
msgstr "\\textit{LEdge} = \\frac{L_1 - L_2}{W_1} + 1\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:37
msgid "The widths of both contours should be about the same:"
msgstr "两个轮廓的宽度应大致相同："

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:39
msgid ""
"\\textit{Width ratio} = \\frac{W_1}{W_2}\n"
"\n"
msgstr "\\textit{Width ratio} = \\frac{W_1}{W_2}\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:41
msgid "The larger stripe should be twice as tall as the smaller one"
msgstr "较大的边应该是较小边的两倍高"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:43
msgid ""
"\\textit{Height ratio} = \\frac{H_1}{2 H_2}\n"
"\n"
msgstr "\\textit{Height ratio} = \\frac{H_1}{2 H_2}\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:45
msgid "Each of these ratios is then turned into a 0-100 score by calculating:"
msgstr "然后通过计算，将每个比率转化为0-100分："

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:47
msgid ""
"100 - (100 \\cdot \\mathrm{abs}(1 - \\textit{Val}))\n"
"\n"
msgstr "100 - (100 \\cdot \\mathrm{abs}(1 - \\textit{Val}))\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:49
msgid ""
"To determine distance, measure pixels from top of top bounding box to bottom"
" of bottom bounding box:"
msgstr "测量顶部外接矩形的顶部到底部外接矩形的底部的像素长度，来确定距离:"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:51
msgid ""
"\\textit{distance} = \\frac{\\textit{Target height in ft.} (10/12) \\cdot \\textit{YRes}}{2 \\cdot \\textit{PixelHeight} \\cdot \\tan (\\textit{viewAngle of camera})}\n"
"\n"
msgstr ""
"\\textit{distance} = \\frac{\\textit{Target height in ft.} (10/12) \\cdot "
"\\textit{YRes}}{2 \\cdot \\textit{PixelHeight} \\cdot \\tan "
"(\\textit{viewAngle of camera})}\n"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:53
msgid ""
"The LabVIEW example uses height as the edges of the round target are the "
"most prone to noise in detection (as the angle points further from the "
"camera   the color looks less green). The downside of this is that the pixel"
" height of the target in the image is affected by perspective distortion "
"from the angle of the camera. Possible fixes include:"
msgstr ""
"LabVIEW的例子使用了高度来确定距离，因为圆形目标的边缘在检测中最容易产生噪声(因为角度点离摄像机越远，颜色看起来越不显绿)。这样做的缺点是，图像中目标的像素高度会受到相机角度的透视失真的影响。可能的方法包括："

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:55
msgid "Try using width instead"
msgstr "尝试使用宽度来代替"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:56
msgid ""
"Empirically measure height at various distances and create a lookup table or"
" regression function"
msgstr "实地测量物体在不同距离时的高度，并创建一个查阅表或回归方程"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:57
msgid ""
"Mount the camera to a servo, center the target vertically in the image and "
"use servo angle for distance calculation (you'll have to work out the proper"
" trig yourself or find a math teacher to help!)"
msgstr "安装相机到一个伺服电机上，使目标在垂直方向上置中，并使用伺服电机的角度计算距离（你将不得不靠自己或者找数学老师帮助解决合适的三角问题！）"

#: ../../frc-docs/source/docs/software/vision-processing/introduction/2017-vision-examples.rst:58
msgid ""
"Correct for the perspective distortion using OpenCV. To do this you will "
"need to `calibrate your camera with OpenCV "
"<https://docs.opencv.org/3.4.6/d4/d94/tutorial_camera_calibration.html>`_. "
"This will result in a distortion matrix and camera matrix. You will take "
"these two matrices and use them with the undistortPoints function to map the"
" points you want to measure for the distance calculation to the \"correct\" "
"coordinates (this is much less CPU intensive than undistorting the whole "
"image)"
msgstr ""
"使用OpenCV校正透视失真。要做到这一点，你需要用OpenCV<https://docs.opencv.org/3.4.6/d4/d94/tutorial_camera_calibration.html>`来校准你的相机。这将生成一个变形矩阵和相机矩阵。您将使用这两个矩阵和undistortPoints方法来将您想要测量的点映射到“实际的”坐标（这比未失真的整个图像要少很多CPU消耗）"
