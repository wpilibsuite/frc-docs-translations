# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, FIRST and other WPILib Contributors. This work is licensed under a Creative Commons Attribution 4.0 International License
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Marc Lalonde, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2024\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-18 04:04+0000\n"
"PO-Revision-Date: 2023-01-27 00:44+0000\n"
"Last-Translator: Marc Lalonde, 2024\n"
"Language-Team: French (Canada) (https://app.transifex.com/wpilib/teams/109324/fr_CA/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr_CA\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:2
msgid "Treating Functions as Data"
msgstr "Traiter les fonctions comme des données"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:4
msgid ""
"Regardless of programming language, one of the first things anyone learns to"
" do when programming a computer is to write a function (also known as a "
"\"method\" or a \"subroutine\").  Functions are a fundamental part of "
"organized code - writing functions lets us avoid duplicating the same piece "
"of code over and over again.  Instead of writing duplicated sections of "
"code, we call a single function that contains the code we want to execute "
"from multiple places (provided we named the function well, the function name"
" is also easier to read than the code itself!).  If the section of code "
"needs some additional information about its surrounding context to run, we "
"pass those to the function as \"parameters\", and if it needs to yield "
"something back to the rest of the code once it finishes, we call that a "
"\"return value\" (together, the parameters and return value are called the "
"function's \"signature\");"
msgstr ""
"Quel que soit le langage de programmation, l’une des premières choses que "
"l’on apprend à faire lors de la programmation d’un ordinateur est d’écrire "
"une fonction (également appelée « méthode » ou « sous-programme »). Les "
"fonctions sont un élément fondamental du code organisé : l'écriture de "
"fonctions nous permet d'éviter de dupliquer encore et encore le même morceau"
" de code. Au lieu d'écrire des sections de code dupliquées, nous appelons "
"une seule fonction qui contient le code que nous voulons exécuter à "
"plusieurs endroits (à condition de bien nommer la fonction, le nom de la "
"fonction est également plus facile à lire que le code lui-même !). Si la "
"section de code a besoin d'informations supplémentaires sur son contexte "
"environnant pour s'exécuter, nous les transmettons à la fonction en tant que"
" \"paramètres\", et si elle doit renvoyer quelque chose au reste du code une"
" fois terminé, nous appelons cela une \"valeur de retour\" (ensemble, les "
"paramètres et la valeur de retour sont appelés la \"signature\" de la "
"fonction) ;"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:6
msgid ""
"Sometimes, we need to pass functions from one part of the code to another "
"part of the code.  This might seem like a strange concept, if we're used to "
"thinking of functions as part of a class definition rather than objects in "
"their own right.  But at a basic level, functions are just data - in the "
"same way we can store an ``integer`` or a ``double`` as a variable and pass "
"it around our program, we can do the same thing with a function.  A variable"
" whose value is a function is called a \"functional interface\" in Java, and"
" a \"function pointer\" or \"functor\" in C++."
msgstr ""
"Parfois, nous devons transmettre des fonctions d’une partie du code à une "
"autre partie du code. Cela peut sembler un concept étrange si nous sommes "
"habitués à considérer les fonctions comme faisant partie d'une définition de"
" classe plutôt que comme des objets à part entière. Mais à la base, les "
"fonctions ne sont que des données - de la même manière que nous pouvons "
"stocker un « entier » ou un « double » comme variable et le transmettre à "
"notre programme, nous pouvons faire la même chose avec une fonction. . Une "
"variable dont la valeur est une fonction est appelée « interface "
"fonctionnelle » en Java et « pointeur de fonction » ou « foncteur » en C++."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:9
msgid "Why Would We Want to Treat Functions as Data?"
msgstr "Pourquoi traiter les fonctions comme des données ?"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:11
msgid ""
"Typically, code that calls a function is coupled to (depends on) the "
"definition of the function. While this occurs all the time, it becomes "
"problematic when the code *calling* the function (for example, WPILib) is "
"developed independently and without direct knowledge of the code that "
"*defines* the function (for example, code from an FRC team). Sometimes we "
"solve this challenge through the use of class interfaces, which define "
"collections of data and functions that are meant to be used together.  "
"However, often we really only have a dependency on a *single function*, "
"rather than on an *entire class*."
msgstr ""
"En règle générale, le code qui appelle une fonction est couplé à (dépend de)"
" la définition de la fonction. Bien que cela se produise tout le temps, cela"
" devient problématique lorsque le code *appelant* la fonction (par exemple, "
"WPILib) est développé indépendamment et sans connaissance directe du code "
"qui *définit* la fonction (par exemple, le code d'une équipe FRC). Parfois, "
"nous résolvons ce problème en utilisant des interfaces de classe, lesquelles"
" définissent des collections de données et de fonctions destinées à être "
"utilisées ensemble. Cependant, souvent, nous n'avons en réalité qu'une "
"dépendance sur une *seule fonction*, plutôt que sur une *classe entière*."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:13
msgid ""
"For example, WPILib offers several ways for users to execute certain code "
"whenever a joystick button is pressed - one of the easiest and cleanest ways"
" to do this is to allow the user to *pass a function* to one of the WPILib "
"joystick methods.  This way, the user only has to write the code that deals "
"with the interesting and team-specific things (e.g., \"move my robot arm\") "
"and not the boring, error-prone, and universal thing (\"properly read button"
" inputs from a standard joystick\")."
msgstr ""
"Par exemple, WPILib propose aux utilisateurs plusieurs façons d'exécuter "
"certains codes chaque fois qu'un bouton du joystick est enfoncé - l'un des "
"moyens les plus simples et les plus propres de le faire est de permettre à "
"l'utilisateur de *passer une fonction* à l'une des méthodes du joystick "
"WPILib. De cette façon, l'utilisateur n'a qu'à écrire le code qui traite des"
" événements intéressants et spécifiques à l'équipe (par exemple, \"bouger "
"mon bras de robot\") et non la chose ennuyeuse, sujette aux erreurs et "
"universelle (\"lire correctement les entrées des boutons depuis un joystick "
"standard\")."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:15
msgid ""
"For another example, the :ref:`Command-based framework "
"<docs/software/commandbased/what-is-command-based:What Is \"Command-Based\" "
"Programming?>` is built on ``Command`` objects that refer to methods defined"
" on various ``Subsystem`` classes.  Many of the included ``Command`` types "
"(such as ``InstantCommand`` and ``RunCommand``) work with *any* function - "
"not just functions associated with a single ``Subsystem``.  To support "
"building commands generically, we need to support passing functions from a "
"``Subsystem`` (which interacts with the hardware) to a ``Command`` (which "
"interacts with the scheduler)."
msgstr ""
"Pour un autre exemple, le :ref:`framework basé sur des commandes "
"<docs/software/commandbased/what-is-command-based:What Is \"Command-Based\" "
"Programming?>` est construit sur des objets ``Command`` qui font référence "
"aux méthodes définies sur diverses classes ``Subsystem``. La plupart des "
"types ``Command`` inclus (tels que ``InstantCommand`` et ``RunCommand``) "
"fonctionnent avec *n'importe quelle* fonction - pas seulement avec les "
"fonctions associées à un seul ``Subsystem``. Pour prendre en charge la "
"construction de commandes de manière générique, nous devons prendre en "
"charge le passage de fonctions d'un ``Subsystem`` (qui interagit avec le "
"matériel) à une ``Command`` (qui interagit avec le planificateur)."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:17
msgid ""
"In these cases, we want to be able to pass a single function as a piece of "
"data, as if it were a variable - it doesn't make sense to ask the user to "
"provide an entire class, when we really just want them to give us a single "
"appropriately-shaped function."
msgstr ""
"Dans ces cas, nous voulons pouvoir transmettre une seule fonction sous forme"
" de données, comme s'il s'agissait d'une variable - cela n'a pas de sens de "
"demander à l'utilisateur de fournir une classe entière, alors que nous "
"voulons simplement qu'il fournisse une seule fonction de conception "
"appropriée."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:19
msgid ""
"It's important that *passing* a function is not the same as *calling* a "
"function.  When we call a function, we execute the code inside of it and "
"either receive a return value, cause some side-effects elsewhere in the "
"code, or both.  When we *pass* a function, nothing in particular happens "
"*immediately.*  Instead, by passing the function we are allowing some "
"*other* code to call the function *in the future.*  Seeing the name of a "
"function in code does not always mean that the code in the function is being"
" run!"
msgstr ""
"Il est important de comprendre que  *passer* une fonction n’est pas la même "
"chose que *appeler* une fonction. Lorsque nous appelons une fonction, nous "
"exécutons le code qu'elle contient et soit nous recevons une valeur de "
"retour, soit nous provoquons des effets secondaires ailleurs dans le code, "
"soit les deux. Lorsque nous *passons* une fonction, rien de particulier ne "
"se produit *immédiatement*. Au lieu de cela, en passant la fonction, nous "
"permettons à un *autre* code d'appeler la fonction *dans le futur*. Voir le "
"nom d'une fonction dans le code ne signifie pas toujours que le code de la "
"fonction est en cours d'exécution !"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:21
msgid ""
"Inside of code that passes a function, we will see some syntax that either "
"refers to the name of an existing function in a special way, or else defines"
" a new function to be passed inside of the call expression.  The specific "
"syntax needed (and the rules around it) depends on which programming "
"language we are using."
msgstr ""
"À l'intérieur du code qui transmet une fonction, nous verrons une syntaxe "
"qui soit fait référence au nom d'une fonction existante d'une manière "
"spéciale, soit définit une nouvelle fonction à transmettre à l'intérieur de "
"l'expression d'appel. La syntaxe spécifique nécessaire (et les règles qui "
"l'entourent) dépend du langage de programmation que nous utilisons."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:24
msgid "Treating Functions as Data in Java"
msgstr "Traiter les fonctions comme des données en Java"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:28
msgid ""
"This might sound complicated, but in the context of WPILib we don't really "
"need to worry much about using the functional interfaces themselves - the "
"code that does that is internal to WPILib.  Instead, all we need to know is "
"how to pass a function that we've written to a method that takes a "
"functional interface as a parameter.  For a simple example, consider the "
"signature of ``Commands.runOnce`` (which creates an ``InstantCommand`` that,"
" when scheduled, runs the given function once and then terminates):"
msgstr ""
"Cela peut sembler compliqué, mais dans le contexte de WPILib, nous n'avons "
"pas vraiment besoin de nous soucier de l'utilisation des interfaces "
"fonctionnelles elles-mêmes : le code qui fait cela est interne à WPILib. Au "
"lieu de cela, tout ce que nous devons savoir, c'est comment transmettre une "
"fonction que nous avons écrite à une méthode qui prend une interface "
"fonctionnelle comme paramètre. Pour un exemple simple, considérons la "
"signature de ``Commands.runOnce`` (qui crée une ``InstantCommand`` qui, "
"lorsqu'elle est planifiée, exécute la fonction donnée une seule fois puis se"
" termine) :"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:30
#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:117
msgid ""
"The ``requirements`` parameter is explained in the :ref:`Command-based "
"documentation <docs/software/commandbased/commands:getRequirements>`, and "
"will not be discussed here."
msgstr ""
"Le paramètre ``requirements`` est expliqué dans la :ref:`Documentation basée"
" sur les commandes <docs/software/commandbased/commands:getRequirements>`, "
"et ne sera pas abordé ici."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:35
msgid ""
"``runOnce`` expects us to give it a ``Runnable`` parameter (named "
"``action``).  A ``Runnable`` is the Java term for a function that takes no "
"parameters and returns no value.  When we call ``runOnce``, we need to give "
"it a function with no parameters and no return value.  There are two ways to"
" do this: we can refer to some existing function using a \"method "
"reference\", or we can define the function we want inline using a \"lambda "
"expression\"."
msgstr ""
"``runOnce`` attend que nous lui donnions un paramètre ``Runnable`` (nommé "
"``action``). Un ``Runnable`` est le terme Java désignant une fonction qui ne"
" prend aucun paramètre et ne renvoie aucune valeur. Lorsque nous appelons "
"``runOnce``, nous devons lui donner une fonction sans paramètres ni valeur "
"de retour. Il existe deux manières de procéder : nous pouvons faire "
"référence à une fonction existante en utilisant une \"référence de "
"méthode\", ou nous pouvons définir la fonction souhaitée en ligne à l'aide "
"d'une \"expression lambda\"."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:38
msgid "Method References"
msgstr "Références de méthodes"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:40
msgid ""
"A method reference lets us pass an already-existing function as our "
"``Runnable``:"
msgstr ""
"Une référence de méthode nous permet de passer une fonction déjà existante "
"comme notre ``Runnable`` :"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:47
msgid ""
"The expression ``drivetrain::resetEncoders`` is a reference to the "
"``resetEncoders`` method of the ``drivetrain`` object.  It is not a method "
"*call* - this line of code does not *itself* reset the encoders of the "
"drivetrain.  Instead, it returns a ``Command`` that will do so *when it is "
"scheduled.*"
msgstr ""
"L'expression ``drivetrain::resetEncoders`` est une référence à la méthode "
"``resetEncoders`` de l'objet ``drivetrain``. Ce n'est pas un *appel* de "
"méthode - cette ligne de code ne réinitialise pas *elle-même* les encodeurs "
"de la transmission. Au lieu de cela, elle renvoie une ``Command``qui le fera"
" *quand cela est planifié.*"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:49
msgid ""
"Remember that in order for this to work, ``resetEncoders`` must be a "
"``Runnable`` - that is, it must take no parameters and return no value.  So,"
" its signature must look like this:"
msgstr ""
"Rappelez-vous que pour que cela fonctionne, ``resetEncoders`` doit être un "
"``Runnable`` - c'est-à-dire qu'il ne doit prendre aucun paramètre et ne "
"renvoyer aucune valeur. Ainsi, sa signature doit ressembler à ceci :"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:56
msgid ""
"If the function signature does not match this, Java will not be able to "
"interpret the method reference as a ``Runnable`` and the code will not "
"compile.  Note that all we need to do is make sure that the signature "
"matches the signature of the single method in the ``Runnable`` functional "
"interface - we don't need to *explicitly* name it as a ``Runnable``."
msgstr ""
"Si la signature de la fonction ne correspond pas à ceci, Java ne pourra pas "
"interpréter la référence de méthode comme un ``Runnable`` et le code ne sera"
" pas compilé. Notez que tout ce que nous devons faire est de nous assurer "
"que la signature correspond à la signature de la méthode unique dans "
"l'interface fonctionnelle ``Runnable`` - nous n'avons pas besoin de la "
"nommer *explicitement* comme ``Runnable``."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:59
msgid "Lambda Expressions in Java"
msgstr "Expressions Lambda en Java"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:61
msgid ""
"If we do not already have a named function that does what we want, we can "
"define a function \"inline\" - that means, right inside of the call to "
"``runOnce``!  We do this by writing our function with a special syntax that "
"uses an \"arrow\" symbol to link the argument list to the function body:"
msgstr ""
"Si nous n'avons pas déjà une fonction nommée qui fait ce que nous voulons, "
"nous pouvons définir une fonction \"inline\" - c'est-à-dire juste à "
"l'intérieur de l'appel à ``runOnce`` ! Nous faisons cela en écrivant notre "
"fonction avec une syntaxe spéciale qui utilise un symbole \"flèche\" pour "
"lier la liste d'arguments au corps de la fonction :"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:68
msgid ""
"Java calls ``() -> { drivetrain.arcadeDrive(0.5, 0.0); }`` a \"lambda "
"expression\"; it may be less-confusingly called an \"arrow function\", "
"\"inline function\", or \"anonymous function\" (because it has no name).  "
"While this may look a bit funky, it is just another way of writing a "
"function - the parentheses before the arrow are the function's argument "
"list, and the code contained in the brackets is the function body.  The "
"\"lambda expression\" here represents a function that calls "
"``drivetrain.arcadeDrive`` with a specific set of parameters - note again "
"that this does not *call* the function, but merely defines it and passes it "
"to the ``Command`` to be run later when the ``Command`` is scheduled."
msgstr ""
"Java appelle ``() -> { drivetrain.arcadeDrive(0.5, 0.0); }`` une "
"\"expression lambda\" ; elle peut être appelée de manière moins déroutante «"
" fonction flèche », « fonction inline » ou « fonction anonyme » (car elle "
"n'a pas de nom). Bien que cela puisse paraître un peu étrange, il s'agit "
"simplement d'une autre façon d'écrire une fonction : les parenthèses avant "
"la flèche sont la liste des arguments de la fonction, et le code contenu "
"entre parenthèses est le corps de la fonction. L'expression \"lambda\" "
"représente ici une fonction qui appelle ``drivetrain.arcadeDrive`` avec un "
"ensemble spécifique de paramètres - notez encore que cela n'*appelle pas* la"
" fonction, mais la définit simplement et la transmet à la ``Command`` pour "
"être exécuté plus tard lorsque la ``Command`` est planifiée."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:70
msgid ""
"As with method references, we do not need to *explicitly* name the lambda "
"expression as a ``Runnable`` - Java can infer that our lambda expression is "
"a ``Runnable`` so long as its signature matches that of the single method in"
" the ``Runnable`` interface.  Accordingly, our lambda takes no arguments and"
" has no return statement - if it did not match the ``Runnable`` contract, "
"our code would fail to compile."
msgstr ""
"Comme pour les références de méthode, nous n'avons pas besoin de nommer "
"*explicitement* l'expression lambda comme ``Runnable`` - Java peut déduire "
"que notre expression lambda est un ``Runnable`` tant que sa signature "
"correspond à celle de la méthode unique. dans l'interface ``Runnable``. En "
"conséquence, notre lambda ne prend aucun argument et n'a pas d'instruction "
"return - s'il ne correspondait pas au contrat ``Runnable``, notre code ne "
"pourrait pas être compilé."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:73
msgid "Capturing State in Java Lambda Expressions"
msgstr "Capture de l'état dans les expressions lambda en Java"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:75
#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:144
msgid ""
"In the above example, our function body references an object that lives "
"outside of the function itself (namely, the ``drivetrain`` object).  This is"
" called a \"capture\" of a variable from the surrounding code (which is "
"sometimes called the \"outer scope\" or \"enclosing scope\").  Usually the "
"captured variables are either local variables from the enclosing method body"
" in which the lambda expression is defined, or else fields of an enclosing "
"class definition in which that method is defined."
msgstr ""
"Dans l'exemple ci-dessus, le corps de notre fonction fait référence à un "
"objet qui vit en dehors de la fonction elle-même (à savoir, l'objet "
"``drivetrain``). C'est ce qu'on appelle une « capture » d'une variable à "
"partir du code environnant (qui est parfois appelé « portée externe » ou « "
"portée englobante »). Habituellement, les variables capturées sont soit des "
"variables locales du corps de la méthode englobante dans laquelle "
"l'expression lambda est définie, soit des champs d'une définition de classe "
"englobante dans laquelle cette méthode est définie."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:77
msgid ""
"In Java capturing state is a fairly safe thing to do in general, with one "
"major caveat: we can only capture state that is \"effectively final\".  That"
" means it is only legal to capture a variable from the enclosing scope if "
"that variable is never reassigned after initialization.  Note that this does"
" not mean that the captured state cannot change: Remember that Java objects "
"are references, so the object that the reference *points to* may change "
"after capture - but the reference itself cannot be made to point to another "
"object."
msgstr ""
"En Java, la capture d’un état est une chose assez sûre à faire en général, "
"avec toutefois une mise en garde majeure : nous ne pouvons capturer que "
"l'état « effectivement final ». Cela signifie qu'il n'est légal de capturer "
"une variable de la portée englobante que si cette variable n'est jamais "
"réaffectée après l'initialisation. Notez que cela ne signifie pas que l'état"
" capturé ne peut pas changer : rappelez-vous que les objets Java sont des "
"références, donc l'objet vers lequel la référence *pointe* peut changer "
"après la capture - mais la référence elle-même ne peut pas pointer vers un "
"autre objet."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:79
msgid ""
"This means we can only capture primitive types (like ``int``, ``double``, "
"and ``boolean``) if they're constants.  If we want to capture a state "
"variable that can change, it *must be wrapped in a mutable object*."
msgstr ""
"Cela signifie que nous ne pouvons capturer les types primitifs (comme "
"``int``, ``double`` et ``boolean``) que s'ils sont des constantes. Si nous "
"voulons capturer une variable d'état qui peut changer, elle *doit être "
"enveloppée dans un objet mutable*."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:82
msgid "Syntactic Sugar for Java Lambda Expressions"
msgstr "Sucre syntaxique pour les expressions lambda en Java"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:84
msgid ""
"The full lambda expression syntax can be needlessly verbose in some cases.  "
"To help with this, Java lets us take some shortcuts (called \"syntactic "
"sugar\") in cases where some of the notation is redundant."
msgstr ""
"La syntaxe complète de l'expression lambda peut être inutilement verbeuse "
"dans certains cas. Pour nous aider, Java nous permet de prendre quelques "
"raccourcis (appelés « sucre syntaxique ») dans les cas où une partie de la "
"notation est redondante."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:87
msgid "Omitting Function Body Brackets for One-Line Lambdas"
msgstr "Omission des crochets de fonction pour les lambdas à une ligne"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:89
msgid ""
"If the function body of our lambda expression is only one line, Java lets us"
" omit the brackets around the function body.  When omitting function "
"brackets, we also omit trailing semicolons And the `return` keyword."
msgstr ""
"Si le corps de la fonction de notre expression lambda ne comporte qu'une "
"seule ligne, Java nous permet d'omettre les crochets autour du corps de la "
"fonction. Lorsque nous omettons les parenthèses de fonction, nous omettons "
"également les points-virgules de fin de ligne et le mot-clé `return`."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:91
msgid "So, our ``Runnable`` lambda above could instead be written:"
msgstr ""
"Ainsi, notre lambda ``Runnable`` ci-dessus pourrait à la place être écrit :"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:99
msgid "Omitting Parentheses around Single Lambda Parameters"
msgstr "Omission des parenthèses autour des paramètres lambda uniques"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:101
msgid ""
"If the lambda expression is for a functional interface that takes only a "
"single argument, we can omit the parenthesis around the parameter list:"
msgstr ""
"Si l'expression lambda est destinée à une interface fonctionnelle qui ne "
"prend qu'un seul argument, nous pouvons omettre la parenthèse autour de la "
"liste des paramètres:"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:109
msgid "Treating Functions as Data in C++"
msgstr "Traiter les fonctions comme des données en C++"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:111
msgid ""
"C++ has a number of ways to treat functions as data.  For the sake of this "
"article, we'll only talk about the parts that are relevant to using WPILibC."
msgstr ""
"C++ propose plusieurs façons de traiter les fonctions comme des données. "
"Dans le cadre de cet article, nous ne parlerons que des parties pertinentes "
"pour l'utilisation de WPILibC."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:115
msgid ""
"This sounds a lot more complicated than it is to use in practice.  Let's "
"look at the call signature of ``cmd::RunOnce`` (which creates an "
"``InstantCommand`` that, when scheduled, runs the given function once and "
"then terminates):"
msgstr ""
"Cela semble beaucoup plus compliqué que son utilisation en pratique. "
"Regardons la signature d'appel de ``cmd::RunOnce`` (qui crée une "
"``InstantCommand`` qui, lorsqu'elle est planifiée, exécute la fonction "
"donnée une seule fois puis se termine) :"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:125
msgid ""
"``runOnce`` expects us to give it a ``std::function<void()>`` parameter "
"(named ``action``).  A ``std::function<void()>`` is the C++ type for a "
"``std::function`` that takes no parameters and returns no value (the "
"template parameter, ``void()``, is a function type with no parameters and no"
" return value).  When we call ``runOnce``, we need to give it a function "
"with no parameters and no return value.  C++ lacks a clean way to refer to "
"existing class methods in a way that can automatically be converted to a "
"``std::function``, so the typical way to do this is to define a new function"
" inline with a \"lambda expression\"."
msgstr ""
"``runOnce`` attend que nous lui donnions un paramètre "
"``std::function<void()>`` (nommé ``action``). Un ``std::function<void()>`` "
"est le type C++ pour une ``std::function`` qui ne prend aucun paramètre et "
"ne renvoie aucune valeur (le paramètre du modèle, ``void()`` est un type de "
"fonction sans paramètres ni valeur de retour). Lorsque nous appelons "
"``runOnce``, nous devons lui donner une fonction sans paramètres ni valeur "
"de retour. C++ ne dispose pas d'un moyen simple de faire référence aux "
"méthodes de classe existantes d'une manière qui puisse être automatiquement "
"convertie en ``std::function``, donc la manière typique de le faire est de "
"définir une nouvelle fonction en ligne avec une \"expression lambda\". "

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:128
msgid "Lambda Expressions in C++"
msgstr "Expressions lambda en C++"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:130
msgid ""
"To pass a function to ``runOnce``, we need to write a short inline function "
"expression using a special syntax that resembles ordinary C++ function "
"declarations, but varies in a few important ways:"
msgstr ""
"Pour passer une fonction à ``runOnce``, nous devons écrire une courte "
"expression de fonction en ligne en utilisant une syntaxe spéciale qui "
"ressemble aux déclarations de fonctions C++ ordinaires, mais qui varie de "
"plusieurs manières importantes:"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:137
msgid ""
"C++ calls ``[captures] (params) { body; }`` a \"lambda expression\".  It has"
" three parts: a *capture list* (square brackets), an optional *parameter "
"list* (parentheses), and a *function body* (curly brackets).  It may look a "
"little strange, but the only real difference between a lambda expression and"
" an ordinary function (apart from the lack of a function name) is the "
"addition of the capture list."
msgstr ""
"C++ appelle ``[captures] (params) { body; }`` une \"expression lambda\". "
"Elle comporte trois parties : une *liste de capture* (crochets), une *liste "
"de paramètres* facultative (parenthèses) et un *corps de fonction* "
"(accolades). Cela peut paraître un peu étrange, mais la seule vraie "
"différence entre une expression lambda et une fonction ordinaire (mis à part"
" l'absence de nom de fonction) est l'ajout de la liste de capture."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:139
msgid ""
"Since ``RunOnce`` wants a function with no parameters and no return value, "
"our lambda expression has no parameter list and no return statement.  The "
"\"lambda expression\" here represents a function that calls "
"``drivetrain.ArcadeDrive`` with a specific set of parameters - note again "
"that the above code does not *call* the function, but merely defines it and "
"passes it to the ``Command`` to be run later when the ``Command`` is "
"scheduled."
msgstr ""
"Puisque ``RunOnce`` veut une fonction sans paramètres ni valeur de retour, "
"notre expression lambda n'a pas de liste de paramètres ni d'instruction de "
"retour. L'expression \"lambda\" représente ici une fonction qui appelle "
"``drivetrain.ArcadeDrive`` avec un ensemble spécifique de paramètres - notez"
" encore que le code ci-dessus n'*appelle pas* la fonction, mais la définit "
"simplement et la transmet à la `` Command`` à exécuter plus tard lorsque la "
"``Command`` est planifiée."

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:142
msgid "Capturing State in C++ Lambda Expressions"
msgstr "Capture de l'état dans les expressions lambda en C++"

#: ../../frc-docs/source/docs/software/basic-programming/functions-as-data.rst:146
msgid ""
"C++ has somewhat more-powerful semantics than Java.  One cost of this is "
"that we generally need to give the C++ compiler some help to figure out *how"
" exactly* we want it to capture state from the enclosing scope.  This is the"
" purpose of the *capture list*.  For the purposes of using the WPILibC "
"Command-based framework, it is usually sufficient to use a capture list of "
"``[this]``, which gives access to members of the enclosing class by "
"capturing the enclosing class's ``this`` pointer by value."
msgstr ""
"C++ a une sémantique un peu plus puissante que Java. L'un des coûts de cela "
"est que nous devons généralement aider le compilateur C++ pour déterminer "
"*comment exactement* nous voulons qu'il capture l'état de la portée "
"englobante. C'est le but de la *liste de capture*. Pour utiliser le "
"framework basé sur les commandes WPILibC, il suffit généralement d'utiliser "
"une liste de capture de ``[this]``, qui donne accès aux membres de la classe"
" englobante en capturant le pointeur ``this`` de la classe englobante par "
"valeur."
