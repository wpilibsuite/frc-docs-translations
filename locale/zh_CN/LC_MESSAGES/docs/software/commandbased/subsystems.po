# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, FIRST and other WPILib Contributors
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jiangshan Gong <jiangshan_gong@163.com>, 2020
# Yitong Zhao <lucius300er@outlook.com>, 2021
# Team 5308 <team5308@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2021\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-21 04:04+0000\n"
"PO-Revision-Date: 2020-04-25 02:02+0000\n"
"Last-Translator: Team 5308 <team5308@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/wpilib/teams/109324/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:2
msgid "Subsystems"
msgstr "子系统"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:4
msgid ""
"Subsystems are the basic unit of robot organization in the command-based "
"paradigm. A subsystem is an abstraction for a collection of robot hardware "
"that *operates together as a unit*. Subsystems `encapsulate "
"<https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>`__ this"
" hardware, \"hiding\" it from the rest of the robot code (e.g. commands) and"
" restricting access to it except through the subsystem’s public methods. "
"Restricting the access in this way provides a single convenient place for "
"code that might otherwise be duplicated in multiple places (such as scaling "
"motor outputs or checking limit switches) if the subsystem internals were "
"exposed. It also allows changes to the specific details of how the subsystem"
" works (the \"implementation\") to be isolated from the rest of robot code, "
"making it far easier to make substantial changes if/when the design "
"constraints change."
msgstr ""
"子系统是基于命令的范例中机器人组织的基本单元。子系统是*可以作为一个单元*一起操作的机器人硬件集合的抽象。子系统将这个硬件封装为<https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>，将其“隐藏”在机器人代码的其余部分（例如命令）中，并限制对它的访问，除非通过子系统的公共方法。如果子系统内部暴露在外，以这种方式限制访问可为代码提供一个方便的位置，否则该代码可能会在多个位置重复（例如缩放电动机输出或检查限位开关）。它还允许将子系统工作方式的特定细节（“实现”）的更改与其余的机器人代码隔离开，从而在设计约束发生更改时进行实质性更改要容易得多。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:6
msgid ""
"Subsystems also serve as the backbone of the ``CommandScheduler``\\ ’s "
"resource management system. Commands may declare resource requirements by "
"specifying which subsystems they interact with; the scheduler will never "
"concurrently schedule more than one command that requires a given subsystem."
" An attempt to schedule a command that requires a subsystem that is already-"
"in-use will either interrupt the currently-running command (if the command "
"has been scheduled as interruptible), or else be ignored."
msgstr ""
"子系统还充当“ "
"CommandScheduler”资源管理系统的骨干。命令可以通过指定与哪些子系统交互来声明资源需求。调度程序永远不会同时调度多个需要给定子系统的命令。尝试调度需要已在使用中的子系统的命令时，将中断当前正在运行的命令（如果该命令已被安排为可中断），否则将被忽略。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:11
msgid "Creating a Subsystem"
msgstr "创建子系统"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:33
msgid ""
"This class contains a few convenience features on top of the basic "
"``Subsystem`` interface: it automatically calls the ``register()`` method in"
" its constructor to register the subsystem with the scheduler (this is "
"necessary for the ``periodic()`` method to be called when the scheduler "
"runs), and also implements the ``Sendable`` interface so that it can be sent"
" to the dashboard to display/log relevant status information."
msgstr ""
"此类在基本的“Subsystem”接口之上包含一些便利功能：它会在其构造函数中自动调用\"register()”方法以向调度程序注册子系统（这对于在调度程序运行时调用“periodic()”方法是必须的），并实现“Sendable”接口，以便将其发送到仪表板以显示/记录相关状态信息。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:35
msgid ""
"Advanced users seeking more flexibility may simply create a class that "
"implements the ``Subsystem`` interface."
msgstr "寻求更高灵活性的高级用户可以简单地创建一个实现“Subsystem”接口的类。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:38
msgid "Simple Subsystem Example"
msgstr "简单子系统示例"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:40
msgid ""
"What might a functional subsystem look like in practice? Below is a simple "
"pneumatically-actuated hatch mechanism from the HatchBot example project "
"(`Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__,"
" `C++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__):"
msgstr ""
"在实践中，功能子系统会是什么样？以下是HatchBot示例项目中的一个简单的气动孵化机制（`Java "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/hatchbottraditional>`__，`C"
" ++ "
"<https://github.com/wpilibsuite/allwpilib/tree/main/wpilibcExamples/src/main/cpp/examples/HatchbotTraditional>`__）："

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:68
msgid ""
"Notice that the subsystem hides the presence of the DoubleSolenoid from "
"outside code (it is declared ``private``), and instead publicly exposes two "
"higher-level, descriptive robot actions: ``grabHatch()`` and "
"``releaseHatch()``. It is extremely important that \"implementation "
"details\" such as the double solenoid be \"hidden\" in this manner; this "
"ensures that code outside the subsystem will never cause the solenoid to be "
"in an unexpected state. It also allows the user to change the implementation"
" (for instance, a motor could be used instead of a pneumatic) without any of"
" the code outside of the subsystem having to change with it."
msgstr ""
"请注意，子系统从外部代码隐藏了DoubleSolenoid的存在（被声明为``private''），而是公开公开了两个更高级别的描述性机器人动作：``grabHatch（）''和``releaseHatch（）''"
" "
"``。以这种方式“隐藏”双螺线管之类的“实现细节”是极为重要的；这样可以确保子系统外部的代码永远不会导致螺线管处于意外状态。它还允许用户更改实现方式（例如，可以使用电动机代替气动方式），而子系统外部的任何代码都不必随之更改。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:71
msgid "Setting Default Commands"
msgstr "设置默认命令"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:73
msgid ""
"In the C++ command-based library, the CommandScheduler `owns` the default "
"command objects - accordingly, the object passed to the "
"``SetDefaultCommand()`` method will be either moved or copied, depending on "
"whether it is an rvalue or an lvalue (`rvalue/lvalue explanation "
"<http://thbecker.net/articles/rvalue_references/section_01.html>`__).  The "
"examples here ensure that move semantics are used by casting to an rvalue "
"with ``std::move()``."
msgstr ""
"在基于C "
"++命令的库中，CommandScheduler“拥有”默认命令对象——因此，传递给“SetDefaultCommand()”方法的对象将被移动或复制，具体取决于它是右值还是左值（`rvalue/lvalue"
" explanation "
"<http://thbecker.net/articles/rvalue_references/section_01.html>`__）。这里的示例通过使用“std::move()”强制转换为右值来确保使用移动语义。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:75
msgid ""
"\"Default commands\" are commands that run automatically whenever a "
"subsystem is not being used by another command."
msgstr "“默认命令”是每当子系统不被另一个命令使用时自动运行的命令。"

#: ../../frc-docs/source/docs/software/commandbased/subsystems.rst:77
msgid ""
"Setting a default command for a subsystem is very easy; one simply calls "
"``CommandScheduler.getInstance().setDefaultCommand()``, or, more simply, the"
" ``setDefaultCommand()`` method of the ``Subsystem`` interface:"
msgstr ""
"为子系统设置默认命令非常容易：简单地调用“CommandScheduler.getInstance().setDefaultCommand()”，或调用“Subsystem”接口的“setDefaultCommand()”方法："
