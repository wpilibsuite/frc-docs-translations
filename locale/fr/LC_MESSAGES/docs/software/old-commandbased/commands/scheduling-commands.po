# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, FIRST
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Regis Bekale <rbekale@robotiquefirstquebec.org>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2020\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-26 00:48-0700\n"
"PO-Revision-Date: 2020-04-25 02:04+0000\n"
"Last-Translator: Regis Bekale <rbekale@robotiquefirstquebec.org>, 2020\n"
"Language-Team: French (Canada) (https://www.transifex.com/wpilib/teams/109324/fr_CA/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr_CA\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:2
msgid "Scheduling Commands"
msgstr "Planification des commandes"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:4
msgid ""
"This documentation describes the use of the legacy command-based library. "
"While this documentation has been preserved to help teams that have yet to "
"do so, teams are strongly encouraged to migrate to the :ref:`new command-"
"based library <docs/software/commandbased/index:Command-Based Programming>`."
msgstr ""
"Cette documentation décrit l’utilisation de la bibliothèque patrimoniale "
"orientée commande. Bien que cette documentation ait été conservée pour aider"
" les équipes qui ne l’ont pas encore fait, les équipes sont fortement "
"encouragées à migrer vers la :ref:`nouvelle bibliothèque orientée commande "
"<docs/software/commandbased/index:Command-Based Programming>`."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:6
msgid ""
"Commands are scheduled to run based on a number of factors such as triggers,"
" default commands when no other running commands require a subsystem, a "
"prior command in a group finishes, button presses, autonomous period "
"starting, etc. Although many commands may be running virtually at the same "
"time, there is only a single thread (the main robot thread). This is to "
"reduce the complexity of synchronization between threads. There are threads "
"that run in the system for systems like PID loops, communications, etc. but "
"those are all self contained with very little interaction requiring complex "
"synchronization. This makes the system much more robust and predictable."
msgstr ""
"Les commandes sont planifiées pour s’exécuter en fonction d’un certain "
"nombre de facteurs tels que les déclencheurs, les commandes par défaut "
"lorsqu’aucune autre commande en cours d’exécution ne nécessite un sous-"
"système, une commande précedente qui se termine dans un groupe de commandes,"
" des boutons de joystick qu'on appuie, le démarrage de modes autonomes, etc."
" Bien que de nombreuses commandes puissent être en cours d’exécution "
"pratiquement en même temps, il n’y a qu’un seul fil d'exécution (le "
"principal fil d'exécution du robot). Il s’agit de réduire la complexité de "
"la synchronisation entre les fils d'exécution. Il y a des fils d'exécution "
"qui s’exécutent dans le système pour des systèmes comme les boucles PID, les"
" communications, etc, mais ceux-ci sont tous autonomes avec très peu "
"d’interaction nécessitant une synchronisation complexe. Ce qui rend le "
"système beaucoup plus robuste et prévisible."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:8
msgid ""
"This is accomplished by a class called Scheduler. It has a ``run()`` method "
"that is called periodically (typically every 20ms in response to a driver "
"station update) that tries to make progress on every command that is "
"currently running. This is done by calling the ``execute()`` method on the "
"command followed by the ``isFinished()`` method. If ``isFinished()`` returns"
" true, the command is marked to be removed from execution  on the next pass "
"through the scheduler. So if there are a number of commands all scheduled to"
" run at the same time, then every time the ``Scheduler.run()`` method is "
"called, each of the active commands execute() and ``isFinished()`` methods "
"are called. This has the same effect as using multiple threads."
msgstr ""
"Ceci est accompli par une classe appelée Scheduler. Il dispose d’une méthode"
" ``run()`` qui est appelée périodiquement (généralement tous les 20ms en "
"réponse à une mise à jour de la station de pilote) qui tente de faire des "
"progrès sur chaque commande qui est actuellement en cours d’exécution. Pour "
"ce faire, il s’agit d’appeler la méthode ``execute()`` sur la commande "
"suivie de la méthode ``isFinished()``. Si ``isFinished()`` retourne TRUE, la"
" commande est marquée pour être supprimée de l’exécution au passage suivant "
"dans le planificateur. Ainsi, s’il y a un certain nombre de commandes toutes"
" planifiées pour s’exécuter en même temps, ainsi à chaque fois que la "
"méthode  ``Scheduler.run()`` est appelée, les méthodes ``execute()`` et "
"``isFinished()`` de chacune des commandes sont appelées. Cela a le même "
"effet que l’utilisation de plusieurs fils d'exécution."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:11
msgid "Command-Based Program Anatomy"
msgstr "Anatomie d'un programme orienté commandes"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:15
msgid ""
"This shows a typical command-based Robot program and all the code needed to "
"ensure that commands are scheduled correctly. The ``Scheduler.run`` method "
"causes one pass through the scheduler which will let each currently active "
"command run through its ``execute()`` and ``isFinished()`` methods. Ignore "
"the ``log()`` methods in the Java example."
msgstr ""
"Ceci montre un programme robot orienté commande typique et tout le code "
"nécessaire pour s’assurer que les commandes sont planifiées correctement. La"
" méthode ``Scheduler.run`` crée un défilé à travers le planificateur qui "
"permet à chaque commande actuellement active de passer par ses méthodes  "
"``execute()``  et ``isFinished()``. Ignorer les méthodes ``log()`` dans "
"l’exemple Java."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:18
msgid "Command Life Cycle"
msgstr "Cycle de vie d'une commande"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:22
msgid ""
"The work in command-based programs occurs whenever the ``Scheduler.Run`` "
"(C++) or ``Scheduler.run`` (Java) method is called. This is typically called"
" on each driver station update which occurs every 20 ms or 50 times per "
"second. The pseudo code illustrates what happens on each call to the run "
"method."
msgstr ""
"Le travail dans les programmes orienté commandes se produit à chaque fois "
"que la méthode ``Scheduler.Run`` (C++) ou ``Scheduler.run`` (Java) est "
"appelée. Celle-ci est généralement appelée à chaque mise à jour de la Driver"
" Station qui se produit tous les 20 ms ou 50 fois par seconde. Le pseudo "
"code illustre ce qui se passe à chaque appel à la méthode ``Scheduler.Run`` "
"(C++) ou ``Scheduler.run`` (Java)."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:24
msgid ""
"Buttons and triggers are polled to see if the associated commands should be "
"scheduled. If the trigger is true, the command is added to a list of "
"commands that should be scheduled."
msgstr ""
"Les boutons et les déclencheurs sont scrutés pour voir si les commandes qui "
"leur sont associées doivent être planifiées. Si le déclencheur est TRUE, la "
"commande est ajoutée à une liste de commandes qui doit être planifiée."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:25
msgid ""
"Loop through the list of all the commands that are currently runnable and "
"call their execute and isFinished methods. Commands where the isFinished "
"method returns true are removed from the list of currently running commands."
msgstr ""
"Parcourez la liste de toutes les commandes qui sont actuellement exécutables"
" et appelez leurs méthodes ``execute()`` et ``isFInished()``. Les commandes "
"dans lesquelles la méthode ``isFinished()`` renvoie TRUE sont supprimées de "
"la liste des commandes en cours d’exécution."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:26
msgid ""
"Loop through all the commands that have been scheduled to run in the "
"previous steps. Those commands are added to the list of running commands."
msgstr ""
"Parcourez toutes les commandes qui ont été planifiées pour s’exécuter dans "
"les étapes précédentes. Ces commandes sont ajoutées à la liste des commandes"
" en cours d’exécution."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:27
msgid ""
"Default commands are added for each subsystem that currently has no commands"
" running that require that subsystem."
msgstr ""
"Des commandes par défaut sont ajoutées pour chaque sous-système qui n’a "
"actuellement aucune commande en cours d’exécution qui nécessite ce sous-"
"système."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:30
msgid "Optimizing Command Groups"
msgstr "Optimisation des groupes de commandes"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:52
msgid ""
"Once you have working commands that operate the mechanisms on your robot you"
" can combine those commands into groups to make more complex actions. "
"Commands can be added to command groups to execute sequentially or in "
"parallel. Sequential commands wait until they are finished (isFinished "
"method returns true) before running the next command in the group. Parallel "
"commands start running, then immediately schedule the next command in the "
"group."
msgstr ""
"Une fois que vous avez des commandes fonctionnelles qui actionnent les "
"mécanismes sur votre robot, vous pouvez combiner ces commandes en groupes "
"pour réaliser des actions plus complexes. Les commandes peuvent être "
"ajoutées aux groupes de commandes pour être exécutées séquentiellement ou en"
" parallèle. Les commandes séquentielles attendent qu’elles soient terminées "
"(la méthode ``isFinished()`` renvoie TRUE) avant d’exécuter la commande "
"suivante dans le groupe. Les commandes parallèles commencent à s’exécuter, "
"puis planifient immédiatement la commande suivante dans le groupe."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:54
msgid ""
"It is important to notice that the commands are added to the group in the "
"constructor. The command group is simply a list of command instances that "
"run when scheduled and any parameters that are passed to the commands are "
"evaluated during the constructor for the group."
msgstr ""
"Il est important de noter que les commandes sont ajoutées au groupe dans le "
"constructeur. Le groupe de commandes est simplement une liste d’instances de"
" commandes qui s’exécutent lorsqu’elles sont planifiées et tous les "
"paramètres qui sont passés aux commandes sont évalués au cours de "
"l'évaluation du constructeur pour le groupe."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:56
msgid ""
"Imagine that in a robot design, there is a claw, attached to a wrist joint "
"and all of those on an elevator. When picking up something, the claw needs "
"to close first before either the elevator or wrist can move otherwise the "
"object may slip out of the claw. In the example shown above the "
"``CloseClaw`` command will be scheduled first. After it is finished (the "
"claw is closed), the wrist will move to it's setpoint and in parallel, the "
"elevator will move. This gets both the elevator and wrist moving "
"simultaneously optimizing the time required to complete the task."
msgstr ""
"Imaginez que dans une conception de robot, il y a une pince, attachée à un "
"joint de poignet et tous sont montés sur un élavateur. Lorsque vous ramassez"
" quelque chose, la pince doit se fermer avant que l’elevateur ou le poignet "
"puisse se déplacer sinon l’objet peut glisser hors de la pince. Dans "
"l’exemple ci-dessus, la commande ``CloseClaw`` sera planifiée en premier. "
"Une fois que son exécution est finie (la pince est fermée), le poignet se "
"déplacera vers son point de consigne et, en parallèle, l’élevateur se "
"déplacera. Ce qui permet à l’élevateur et au poignet de se déplacer "
"simultanément en optimisant ainsi le temps nécessaire pour terminer la "
"tâche."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:59
msgid "When do command groups finish?"
msgstr "Quand les groupes de commandes se terminent-ils ?"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:63
msgid ""
"A command group finishes when all the commands started in that group finish."
" This is true regardless of the type of commands that are added to the "
"group. For example, if a number of commands are added in parallel and "
"sequentially, the group is finished when all the commands added to the group"
" are finished. As each command is added to a command group, it is put on a "
"list. As those child commands finish, they are taken off the list. The "
"command group is finished when the list of child commands is empty."
msgstr ""
"L'éxécution d'un groupe de commandes se termine lorsque toutes les commandes"
" qui ont démarré dans ce groupe terminent chacune leur exécution. Cette "
"condition est vraie quel que soit le type de commandes qui sont ajoutées au "
"groupe. Par exemple, si un certain nombre de commandes sont ajoutées en "
"parallèle et séquentiellement, l'exécution du groupe est terminée lorsque "
"toutes les commandes ajoutées au groupe ont terminé leurs exécutions "
"individuelles. Lorsque chaque commande est ajoutée à un groupe de "
"commandement, elle est mise sur une liste. Lorsque ces commandes enfants se "
"terminent, elles sont retirées de la liste. Le groupe de commandes est "
"terminé lorsque la liste des commandes enfants est vide."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:65
msgid ""
"In the Pickup command shown in the example above, the command is finished "
"when ``CloseClaw``, ``SetWristSetpoint``, and ``SetElevatorSetpoint`` all "
"finish. It doesn't matter that some of the commands are sequential and some "
"parallel."
msgstr ""
"Dans la commande Pickup indiquée dans l’exemple ci-dessus, la commande est "
"terminée lorsque ``CloseClaw``, ``SetWristSetpoint``, et "
"``SetElevatorSetpoint``  tous se terminent. Il n’a pas d’importance que "
"certaines des commandes soient séquentielles et certaines parallèles."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:68
msgid "Schedule a Command within a Running Command"
msgstr "Planifier une commande au sein d’une commande en cours d’exécution"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:70
msgid ""
"Commands can be scheduled by calling the ``start()`` method (Java) or "
"``Start()`` method (C++) on a command instance. This will cause the command "
"to be added to the currently running set of commands in the scheduler. This "
"is often useful when a program needs to conditionally schedule one command "
"or another. The newly scheduled command will be added to a list of new "
"commands on this pass through the run method of the scheduler and actually "
"will run the first time on the next pass through the run method. Newly "
"created commands are never executed in the same call to the scheduler run "
"method, always queued for the next call which usually occurs 20ms later."
msgstr ""
"Les commandes peuvent être planifiées en appelant la méthode ``start()``  "
"(Java) ou ``Start()`` (C++) sur une instance de commande. Cela entraînera "
"l’ajout de la commande au jeu de commandes en cours d’exécution dans le "
"planificateur. Ceci est souvent utile lorsqu’un programme doit, sous "
"certaines conditions,   planifier une commande ou une autre. La commande "
"nouvellement planifiée sera ajoutée à une liste de nouvelles commandes sur "
"ce passage de la méthode ``Scheduler.Run`` (C++) ou ``Scheduler.run`` (Java)"
"  du planificateur et s’exécutera en fait la première fois sur le passage "
"suivant à travers la méthode ``Scheduler.Run`` (C++) ou ``Scheduler.run`` "
"(Java) . Les commandes nouvellement créées ne sont jamais exécutées dans le "
"même appel à la méthode ``Scheduler.Run`` (C++) ou ``Scheduler.run`` (Java)"
"  du planificateur mais toujours en file d’attente pour l’appel suivant qui "
"se produit habituellement 20 ms plus tard."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:73
msgid "Removing all Commands from the Scheduler"
msgstr "Suppression de toutes les commandes du planificateur"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:85
msgid ""
"It is occasionally useful to make sure that there are no running commands in"
" the scheduler. To remove all running commands use the "
"``Scheduler.removeAll()`` method (Java) or ``Scheduler::RemoveAll()`` method"
" (C++). This will cause all currently running to have their "
"``interrupted()`` method (Java) or ``Interrupted()`` method (C++) called. "
"Commands that have not yet started will have their ``end()`` method (Java) "
"or ``End()`` method (C++) called."
msgstr ""
"Il est parfois utile de s’assurer qu’il n’y a pas de commandes en cours "
"d’exécution dans le planificateur. Pour supprimer toutes les commandes en "
"cours d’exécution, utilisez la méthode ``Scheduler.removeAll()``  (Java) ou "
"``Scheduler::RemoveAll()`` (C++). Ce qui fera en sorte que toutes les "
"méthodes actuellement en cours d’exécution verront leur méthode  "
"``interrupted()`` (Java) ou``Interrupted()``(C++) appelée. Les commandes qui"
" n’ont pas encore démarrées auront leur méthode  ``end()`` (Java) ou "
"``End()`` (C++) appelée."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:88
msgid "The \"requires\" method"
msgstr "La méthode ``requires()``"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:92
msgid ""
"If you have multiple commands that use the same subsystem it makes sense "
"that they don't run at the same time. For example, if there is a Claw "
"subsystem with OpenClaw and CloseClaw commands, they can't both run at the "
"same time. Each command that uses the Claw subsystem declares that by 1 "
"calling the ``requires()`` method (Java) or ``Requires()`` method (C++). "
"When one of the commands is running, say from a joystick button press, and "
"you try to run another command that also requires the Claw, the second one "
"preempts the first one. Suppose that OpenClaw was running, and you press the"
" button to run the CloseClaw command. The OpenClaw command is interrupted - "
"2 it's interrupted method is called on the next run cycle and the CloseClaw "
"command is scheduled. If you think about it, this is almost always the "
"desired behavior. If you pressed a button to start opening the claw and you "
"change your mind and want to close it, it makes sense for the OpenClaw "
"command to be stopped and the CloseClaw to be started."
msgstr ""
"Si vous avez plusieurs commandes qui utilisent le même sous-système, il est "
"logique qu’elles ne s’exécutent pas en même temps. Par exemple, s’il existe "
"un sous-système Claw avec des commandes OpenClaw et CloseClaw, elles ne "
"peuvent pas tous deux s’exécuter en même temps. Chaque commande qui utilise "
"le sous-système Claw déclare 1 qu’en appelant la méthode ``requires()`` "
"(Java) ou ``Requires()``  (C++). Lorsque l’une des commandes est en cours "
"d’exécution, par exemple à partir d’un bouton de joystick appuyé, et que "
"vous essayez d’exécuter une autre commande qui nécessite également la pince,"
" la seconde préempte la première. Supposons qu’OpenClaw soit en cours "
"d’exécution et que vous appuyez sur le bouton pour exécuter la commande "
"CloseClaw. La commande OpenClaw est interrompue - 2, la méthode "
"``interrupted()`` est appelée sur le cycle d’exécution suivant et la "
"commande CloseClaw est planifiée. Si vous y réfléchissez, c’est presque "
"toujours le comportement souhaité. Si vous avez appuyé sur un bouton pour "
"commencer à ouvrir la pince, que vous changez d’avis et que vous voulez la "
"fermer, il est logique que la commande OpenClaw soit arrêtée et que la "
"commande CloseC soit démarrée."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:94
msgid ""
"A command may require many subsystems, for example a complex autonomous "
"sequence might use a number of subsystems to complete its task."
msgstr ""
"Une commande peut nécessiter de nombreux sous-systèmes, par exemple une "
"séquence autonome complexe peut utiliser un certain nombre de sous-systèmes "
"pour mener à bien sa tâche."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:96
msgid ""
"Command groups automatically require all the subsystems for each of the "
"commands in the group. There is no need to call the requires method for a "
"group."
msgstr ""
"Les groupes de commande requièrent automatiquement tous les sous-systèmes "
"pour chacune des commandes du groupe. Il n’est pas nécessaire d’appeler la "
"méthode ``requires()`` pour un groupe."

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:99
msgid "How are the requirements of a group evaluated?"
msgstr "Comment les exigences d’un groupe sont-elles évaluées?"

#: ../../frc-docs/source/docs/software/old-commandbased/commands/scheduling-commands.rst:101
msgid ""
"The subsystems that a command group requires is the union of the set of "
"subsystems that are required for all of the child commands. If a 4 commands "
"are added to a group, then the group will require all of the subsystems "
"required by each of the 4 commands in the group. For example, if are three "
"commands scheduled in a group - the first requires subsystem A, the second "
"requires subsystem B, and the third requires subsystems C and D. The group "
"will require subsystems A, B, C, and D. If another command is started, say "
"from a joystick button, that requires either A, B, C, or D it will interrupt"
" the entire group including any parallel or sequential commands that might "
"be running from that group."
msgstr ""
"Les sous-systèmes requis par un groupe de commandes sont l’union de "
"l’ensemble de sous-systèmes requis pour toutes les commandes enfants. Si un "
"4 commandes sont ajoutées à un groupe, le groupe exigera tous les sous-"
"systèmes requis par chacune des 4 commandes du groupe. Par exemple, si trois"
" commandes sont planifiées dans un groupe - la première nécessite le sous-"
"système A, la seconde nécessite le sous-système B et la troisième nécessite "
"des sous-systèmes C et D. Le groupe aura besoin des sous-systèmes A, B, C et"
" D. Si une autre commande est démarrée, par exemple à partir d’un bouton de "
"joystick, qui nécessite A, B, C ou D, elle interrompra l’ensemble du groupe,"
" y compris les commandes parallèles ou séquentielles qui pourraient être en "
"cours d’exécution à partir de ce groupe."
