# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, FIRST
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2020\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-22 16:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:2
msgid "Step 3: Creating a Drive Subsystem"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:4
msgid "Now that our drive is characterized, it is time to start writing our robot code *proper*.  As mentioned before, we will use the :ref:`command-based <docs/software/commandbased/what-is-command-based:What Is \"Command-Based\" Programming?>` framework for our robot code.  Accordingly, our first step is to write a suitable drive :ref:`subsystem <docs/software/commandbased/subsystems:Subsystems>` class."
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:6
msgid "The full drive class from the RamseteCommand Example Project (`Java <https://github.com/wpilibsuite/allwpilib/tree/master/wpilibjExamples/src/main/java/edu/wpi/first/wpilibj/examples/ramsetecommand>`__, `C++ <https://github.com/wpilibsuite/allwpilib/tree/master/wpilibcExamples/src/main/cpp/examples/RamseteCommand>`__) can be seen below.  The rest of the article will describe the steps involved in writing this class."
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:35
msgid "Configuring the Drive Encoders"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:37
msgid "The drive encoders measure the rotation of the wheels on each side of the drive.  To properly configure the encoders, we need to specify two things: the ports the encoders are plugged into, and the distance per encoder pulse.  Then, we need to write methods allowing access to the encoder values from code that uses the subsystem."
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:40
msgid "Encoder Ports"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:42
msgid "The encoder ports are specified in the encoder's constructor, like so:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:63
msgid "Encoder Distance per Pulse"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:65
msgid "The distance per pulse is specified by calling the encoder's ``setDistancePerPulse`` method.  Note that for the WPILib Encoder class, \"pulse\" refers to a full encoder cycle (i.e. four edges), and thus will be 1/4 the value that was specified in the FRC-Characterization config.  Remember, as well, that the distance should be measured in meters!"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:86
msgid "Encoder Accessor Method"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:88
msgid "To access the values measured by the encoders, we include the following method:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:108
msgid "We wrap the measured encoder values in a ``DifferentialDriveWheelSpeeds`` object for easier integration with the ``RamseteCommand`` class later on."
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:111
msgid "Configuring the Gyroscope"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:113
msgid "The gyroscope measures the rate of change of the robot's heading (which can then be integrated to provide a measurement of the robot's heading relative to when it first turned on).  In our example, we use the `Analog Devices ADXRS450 FRC Gyro Board <https://www.analog.com/en/landing-pages/001/first.html>`__, which has been included in the kit of parts for several years:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:134
msgid "Gyroscope Accessor Method"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:136
msgid "To access the current heading measured by the gyroscope, we include the following method:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:157
msgid "Configuring the Odometry"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:159
msgid "Now that we have our encoders and gyroscope configured, it is time to set up our drive subsystem to automatically compute its position from the encoder and gyroscope readings."
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:161
msgid "First, we create a member instance of the ``DifferentialDriveOdometry`` class:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:182
msgid "Updating the Odometry"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:184
msgid "The odometry class must be regularly updated to incorporate new readings from the encoder and gyroscope.  We accomplish this inside the subsystem's ``periodic`` method, which is automatically called once per main loop iteration:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:205
msgid "Odometry Accessor Method"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:207
msgid "To access the robot's current computed pose, we include the following method:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:228
msgid "Voltage-Based Drive Method"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:230
msgid "Finally, we must include one additional method - a method that allows us to set the voltage to each side of the drive using the ``setVoltage()`` method of the ``SpeedController`` interface.  The default WPILib drive class does not include this functionality, so we must write it ourselves:"
msgstr ""

#: ../../frc-docs/source/docs/software/examples-tutorials/trajectory-tutorial/creating-drive-subsystem.rst:250
msgid "It is very important to use the ``setVoltage()`` method rather than the ordinary ``set()`` method, as this will automatically compensate for battery \"voltage sag\" during operation.  Since our feedforward voltages are physically-meaningful (as they are based on measured characterization data), this is essential to ensuring their accuracy."
msgstr ""
