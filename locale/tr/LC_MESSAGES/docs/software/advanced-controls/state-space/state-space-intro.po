# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, FIRST and other WPILib Contributors. This work is licensed under a Creative Commons Attribution 4.0 International License
# This file is distributed under the same license as the FIRST Robotics Competition package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Hasan Bilgin <hasanbilgin@fikretyukselfoundation.org>, 2020
# Müfit ALKAYA <mufit.alkaya@tfo.k12.tr>, 2024
# Esra ÖZEMRE <esra.ozemre@tfo.k12.tr>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FIRST Robotics Competition 2024\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-08-18 04:04+0000\n"
"PO-Revision-Date: 2020-10-04 04:16+0000\n"
"Last-Translator: Esra ÖZEMRE <esra.ozemre@tfo.k12.tr>, 2024\n"
"Language-Team: Turkish (Turkey) (https://app.transifex.com/wpilib/teams/109324/tr_TR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: tr_TR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:2
msgid "Introduction to State-Space Control"
msgstr "Durum Uzayı - State-space Kontrolüne Giriş"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:7
msgid "From PID to Model-Based Control"
msgstr "PID'den Model Tabanlı-Model-Based Kontrol"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:9
msgid ""
"When tuning PID controllers, we focus on fiddling with controller parameters"
" relating to the current, past, and future :term:`error` (P, I and D terms) "
"rather than the underlying system states. While this approach works in a lot"
" of situations, it is an incomplete view of the world."
msgstr ""
"PID denetleyicileri ayarlarken, mevcut, geçmiş ve gelecekle ilgili "
"denetleyici parametreleriyle uğraşmaya odaklanıyoruz: temel sistem "
"durumlarından ziyade :term:`error`  (P, I ve D terimleri). Bu yaklaşım pek "
"çok durumda işe yarasa da, eksik bir dünya görüşüdür."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:11
msgid ""
"Model-based control focuses on developing an accurate model of the "
":term:`system` (mechanism) we are trying to control. These models help "
"inform :term:`gains <gain>` picked for feedback controllers based on the "
"physical responses of the system, rather than an arbitrary proportional "
":term:`gain` derived through testing. This allows us not only to predict "
"ahead of time how a system will react, but also test our controllers without"
" a physical robot and save time debugging simple bugs."
msgstr ""
"Model tabanlı kontrol, kontrol etmeye çalıştığımız :term:`system` "
"(mechanism) için doğru bir model geliştirmeye odaklanır. Bu modeller keyfi "
"bir orantılı :term:`gains <gain>` yerine sistemin fiziksel yanıtlarına "
"dayalı olarak geribildirim denetleyicileri tarafından seçilen testler "
"yoluyla elde edilen  :term:`gains <gain>` bilgilendirmeye yardımcı olur. Bu,"
" sadece bir sistemin nasıl tepki vereceğini önceden tahmin etmemize değil, "
"aynı zamanda kontrolörlerimizi fiziksel bir robot olmadan test etmemize ve "
"basit hataların ayıklanmasında zamandan tasarruf etmemize olanak tanır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:18
msgid "Vocabulary"
msgstr "Kelime bilgisi"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:23
msgid "Introduction to Linear Algebra"
msgstr "Doğrusal Cebire Giriş"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:28
msgid "What is State-Space?"
msgstr "Durum Uzayı nedir?"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:35
msgid ""
"In this image, the vectors representing states in state-space are arrows. "
"From now on these vectors will be represented simply by a point at the "
"vector's tip, but remember that the rest of the vector is still there."
msgstr ""
"Bu görüntüde, durum uzayındaki durumları temsil eden vektörler oklardır. Şu "
"andan itibaren bu vektörler, vektörün ucundaki bir nokta ile temsil "
"edilecek, ancak vektörün geri kalanının hala orada olduğunu unutmayın."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:37
msgid ""
"In addition to the :term:`state`, :term:`inputs <input>` and :term:`outputs "
"<output>` are represented as vectors. Since the mapping from the current "
"states and inputs to the change in state is a system of equations, it’s "
"natural to write it in matrix form. This matrix equation can be written in "
"state-space notation."
msgstr ""
":term:`state`, :term:`girişleri <input> :term:`outputs <output>çıkışlarına "
"ek olarak vektörler olarak temsil edilir. Mevcut durumlardan ve girdilerden "
"durumdaki değişime haritalama bir denklemler sistemi olduğundan, bunu matris"
" biçiminde yazmak doğaldır. Bu matris denklemi durum uzayı gösteriminde "
"yazılabilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:40
msgid "What is State-Space Notation?"
msgstr "Durum Uzayı Gösterimi nedir?"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:42
msgid ""
"State-space notation is a set of matrix equations which describe how a "
"system will evolve over time. These equations relate the change in state "
":math:`\\dot{\\mathbf{x}}`, and the :term:`output` :math:`\\mathbf{y}`, to "
"linear combinations of the current state vector :math:`\\mathbf{x}` and "
":term:`input` vector :math:`\\mathbf{u}`."
msgstr ""
"Durum uzayı gösterimi, bir sistemin zaman içinde nasıl gelişeceğini "
"açıklayan bir dizi matris denklemidir. Bu denklemler,  "
":math:`\\dot{\\mathbf{x}}`, and the :term:`output` :math:`\\mathbf{y}`, "
"değişikliklerini mevcut durum vektörünün doğrusal kombinasyonlarıyla "
"ilişkilendirir :math:`\\mathbf{x}` and :term:`input` vector "
":math:`\\mathbf{u}`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:44
msgid ""
"State-space control can deal with continuous-time and discrete-time systems."
" In the continuous-time case, the rate of change of the system's state "
":math:`\\mathbf{\\dot{x}}` is expressed as a linear combination of the "
"current state :math:`\\mathbf{x}` and input :math:`\\mathbf{u}`."
msgstr ""
"Durum alanı kontrolü, sürekli zamanlı ve ayrık zamanlı sistemlerle başa "
"çıkabilir. Sürekli zaman durumunda, sistemin durumunun değişim oranı: "
":math:`\\mathbf{\\dot{x}}` , geçerli durumun doğrusal bir kombinasyonu "
"olarak ifade edilir: :math:`\\mathbf{x}` and input :math:`\\mathbf{u}`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:46
msgid ""
"In contrast, discrete-time systems expresses the state of the system at our "
"next timestep :math:`\\mathbf{x}_{k+1}` based on the current state "
":math:`\\mathbf{x}_k` and input :math:`\\mathbf{u}_k`, where :math:`k` is "
"the current timestep and :math:`k+1` is the next timestep."
msgstr ""
"Buna karşılık, ayrık zamanlı sistemler, bir sonraki zaman adımımızda "
"sistemin durumunu şu anki duruma göre ifade eder. :math:`\\mathbf{x}_{k+1}` "
"ve  mevcut duruma göre :math: `\\ mathbf {x} _k` ve girdi: math: `\\ mathbf "
"{u} _k`, burada :math:`k` geçerli zaman adımıdır ve :math:`k+1` sonraki "
"zaman adımıdır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:48
msgid ""
"In both the continuous- and discrete-time forms, the :term:`output` vector "
":math:`\\mathbf{y}` is expressed as a linear combination of the current "
":term:`state` and :term:`input`. In many cases, the output is a subset of "
"the system's state, and has no contribution from the current input."
msgstr ""
"Hem sürekli hem de ayrık zaman formlarında,`output` vector "
":math:`\\mathbf{y}`, current: term: \"state\" ve:term:`input` ifadelerinin "
"doğrusal bir kombinasyonu olarak ifade edilir . Çoğu durumda, çıktı, sistem "
"durumunun bir alt kümesidir ve akım girişinden hiçbir katkısı yoktur."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:50
msgid ""
"When modeling systems, we first derive the continuous-time representation "
"because the equations of motion are naturally written as the rate of change "
"of a system's state as a linear combination of its current state and inputs."
" We convert this representation to discrete-time on the robot because we "
"update the system in discrete timesteps there instead of continuously."
msgstr ""
"Sistemleri modellerken, ilk olarak sürekli zaman gösterimini türetiyoruz "
"çünkü hareket denklemleri doğal olarak bir sistemin durumunun değişim hızı "
"olarak mevcut durumu ve girdilerinin doğrusal bir kombinasyonu olarak "
"yazılır. Bu gösterimi robot üzerinde ayrık zamana dönüştürüyoruz çünkü "
"sistemi sürekli yerine orada ayrı zaman adımlarında güncelliyoruz."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:52
msgid ""
"The following two sets of equations are the standard form of continuous-time"
" and discrete-time state-space notation:"
msgstr ""
"Aşağıdaki iki denklem seti, sürekli zaman ve ayrık zaman durum uzayı "
"gösteriminin standart biçimidir:"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:54
msgid ""
"\\text{Continuous: }\n"
"\\dot{\\mathbf{x}} &= \\mathbf{A}\\mathbf{x} + \\mathbf{B}\\mathbf{u} \\\\\n"
"\\mathbf{y} &= \\mathbf{C}\\mathbf{x} + \\mathbf{D}\\mathbf{u} \\\\\n"
"\\nonumber \\\\\n"
"\\text{Discrete: }\n"
"\\mathbf{x}_{k+1} &= \\mathbf{A}\\mathbf{x}_k + \\mathbf{B}\\mathbf{u}_k \\\\\n"
"\\mathbf{y}_k &= \\mathbf{C}\\mathbf{x}_k + \\mathbf{D}\\mathbf{u}_k\n"
"\n"
msgstr ""
"\\text{Continuous: }\n"
"\\dot{\\mathbf{x}} &= \\mathbf{A}\\mathbf{x} + \\mathbf{B}\\mathbf{u} \\\\\n"
"\\mathbf{y} &= \\mathbf{C}\\mathbf{x} + \\mathbf{D}\\mathbf{u} \\\\\n"
"\\nonumber \\\\\n"
"\\text{Discrete: }\n"
"\\mathbf{x}_{k+1} &= \\mathbf{A}\\mathbf{x}_k + \\mathbf{B}\\mathbf{u}_k \\\\\n"
"\\mathbf{y}_k &= \\mathbf{C}\\mathbf{x}_k + \\mathbf{D}\\mathbf{u}_k\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:63
msgid ""
"\\begin{array}{llll}\n"
"  \\mathbf{A} & \\text{system matrix}      & \\mathbf{x} & \\text{state vector} \\\\\n"
"  \\mathbf{B} & \\text{input matrix}       & \\mathbf{u} & \\text{input vector} \\\\\n"
"  \\mathbf{C} & \\text{output matrix}      & \\mathbf{y} & \\text{output vector} \\\\\n"
"  \\mathbf{D} & \\text{feedthrough matrix} &  &  \\\\\n"
"\\end{array}\n"
"\n"
msgstr ""
"\\begin{array}{llll}\n"
"\\mathbf{A} & \\text{system matrix} & \\mathbf{x} & \\text{state vector} \\\\\n"
"\\mathbf{B} & \\text{input matrix} & \\mathbf{u} & \\text{input vector} \\\\\n"
"\\mathbf{C} & \\text{output matrix} & \\mathbf{y} & \\text{output vector} \\\\\n"
"\\mathbf{D} & \\text{feedthrough matrix} & & \\\\\n"
"\\end{array}\n"
"\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:71
msgid ""
"A continuous-time state-space system can be converted into a discrete-time "
"system through a process called discretization."
msgstr ""
"Sürekli zaman durum uzay sistemi, ayrıklaştırma adı verilen bir süreçle "
"ayrık zamanlı bir sisteme dönüştürülebilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:73
msgid ""
"In the discrete-time form, the system's state is held constant between "
"updates. This means that we can only react to disturbances as quickly as our"
" state estimate is updated. Updating our estimate more quickly can help "
"improve performance, up to a point. WPILib's ``Notifier`` class can be used "
"if updates faster than the main robot loop are desired."
msgstr ""
"Ayrık zamanlı formda, sistemin durumu güncellemeler arasında sabit tutulur. "
"Bu, rahatsızlıklara yalnızca durum tahminimiz güncellendiğinde tepki "
"verebileceğimiz anlamına gelir. Tahminimizi daha hızlı güncellemek, "
"performansın bir noktaya kadar iyileştirilmesine yardımcı olabilir. "
"WPILib'in ``Notifier`` sınıfı, ana robot döngüsünden daha hızlı "
"güncellemeler isteniyorsa kullanılabilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:75
msgid ""
"While a system's continuous-time and discrete-time matrices A, B, C, and D "
"have the same names, they are not equivalent. The continuous-time matrices "
"describes the rate of change of the state, :math:`\\mathbf{x}`, while the "
"discrete-time matrices describe the system's state at the next timestep as a"
" function of the current state and input."
msgstr ""
"Bir sistemin sürekli zaman ve ayrık zaman matrisleri A, B, C ve D aynı "
"adlara sahipken, bunlar eşdeğer değildir. Sürekli zaman matrisleri, durum "
"değişim oranını açıklarken:math:`\\mathbf{x}` , ayrık zaman matrisleri ise "
"sistemin durumunu bir sonraki zaman adımında mevcut durum ve girdinin bir "
"fonksiyonu olarak tanımlar."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:77
msgid ""
"WPILib's LinearSystem takes continuous-time system matrices, and converts "
"them internally to the discrete-time form where necessary."
msgstr ""
"WPILib'in LinearSystem'i, sürekli zaman sistem matrislerini alır ve bunları "
"gerektiğinde dahili olarak ayrık zaman biçimine dönüştürür."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:84
msgid ""
"We can convert this equation to state-space notation. We can create a system"
" with one state (velocity), one :term:`input` (voltage), and one "
":term:`output` (velocity). Recalling that the first derivative of velocity "
"is acceleration, we can write our equation as follows, replacing velocity "
"with :math:`\\mathbf{x}`, acceleration with :math:`\\mathbf{\\dot{x}}`, and "
"voltage :math:`\\mathbf{V}` with :math:`\\mathbf{u}`:"
msgstr ""
"Bu denklemi durum uzayı gösterimine dönüştürebiliriz. Bir durum (hız), bir "
":term:`input` (voltage) ve bir :term:`output` (velocity) olan bir sistem "
"oluşturabiliriz. Hızın ilk türevinin ivme olduğunu hatırlayarak, "
"denklemimizi aşağıdaki gibi yazabiliriz, hızı şu ile değiştirebiliriz: "
":math:`\\mathbf{x}`, acceleration with :math:`\\mathbf{\\dot{x}}` ve "
"voltaj:math:`\\mathbf{V}` ile : math:`\\mathbf {u}`:"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:97
msgid "Visualizing State-Space Responses: Phase Portrait"
msgstr "Durum Uzayı Yanıtlarını Görselleştirme: Faz Portresi"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:101
msgid ""
"To trace a potential trajectory that a system could take through state-"
"space, choose a point to start at and follow the arrows around. In this "
"example, we might start at :math:`[-2, 0]`. From there, the velocity "
"increases as we swing through vertical and starts to decrease until we reach"
" the opposite extreme of the swing. This cycle of spinning about the origin "
"repeats indefinitely."
msgstr ""
"Bir sistemin durum uzayında alabileceği potansiyel bir yörüngeyi izlemek "
"için, başlamak üzere bir nokta seçin ve etrafındaki okları takip edin. Bu "
"örnekte, :math:`[-2, 0]` ile başlayabiliriz. Oradan, biz dikeyde döndükçe "
"hız artar ve salınımın zıt ucuna ulaşana kadar azalmaya başlar. Kökenle "
"ilgili bu dönme döngüsü sonsuza kadar tekrar eder."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:106
msgid ""
"Note that near the edges of the phase portrait, the X axis wraps around as a"
" rotation of :math:`\\pi` radians counter clockwise and a rotation of "
":math:`\\pi` radians clockwise will end at the same point."
msgstr ""
"Faz portresinin kenarlarının yakınında, X ekseninin saat yönünün tersine: "
"math: `\\pi` radyan dönüşü olarak sarıldığına ve :math:`\\pi` radyanının "
"saat yönünde bir dönüşünün aynı noktada sona ereceğine dikkat edin."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:111
msgid "Visualizing Feedforward"
msgstr "Feedforward'ı Görselleştirme"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:113
msgid ""
"This phase portrait shows the \"open loop\" responses of the system -- that "
"is, how it will react if we were to let the state evolve naturally. If we "
"want to, say, balance the pendulum horizontal (at :math:`(\\frac{\\pi}{2}, "
"0)` in state space), we would need to somehow apply a control :term:`input` "
"to counteract the open loop tendency of the pendulum to swing downward. This"
" is what feedforward is trying to do -- make it so that our phase portrait "
"will have an equilibrium at the :term:`reference` position (or setpoint) in "
"state-space."
msgstr ""
"Bu aşama portresi, sistemin\"open loop\" tepkilerini, yani devletin doğal "
"olarak gelişmesine izin verirsek nasıl tepki vereceğini gösterir. Sarkacı "
"yatay olarak dengelemek istiyorsak  (at :math:`(\\frac{\\pi}{2}, 0)` in "
"state space), bir şekilde bir kontrol uygulamamız gerekir: term: `input` "
"Sarkacın açık döngü eğiliminin aşağı doğru sallanma eğilimine karşı koymak "
"için. Feedforward'ın yapmaya çalıştığı budur - bunu, faz portremizin durum "
"uzayındaT :term:`reference`  AMkonumunda (veya ayar noktasında) bir dengeye "
"sahip olmasını sağlayın."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:121
msgid "Feedback Control"
msgstr "Geri bildirim kontrolü"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:123
msgid ""
"In the case of a DC motor, with just a mathematical model and knowledge of "
"all current states of the system (i.e., angular velocity), we can predict "
"all future states given the future voltage inputs. But if the system is "
"disturbed in any way that isn’t modeled by our equations, like a load or "
"unexpected friction, the angular velocity of the motor will deviate from the"
" model over time. To combat this, we can give the motor corrective commands "
"using a feedback controller."
msgstr ""
"Bir DC motor söz konusu olduğunda, sadece matematiksel bir modelle ve "
"sistemin tüm mevcut durumlarının bilgisiyle (örneğin, açısal hız), "
"gelecekteki voltaj girişleri verildiğinde gelecekteki tüm durumları tahmin "
"edebiliriz. Ancak sistem, bir yük veya beklenmedik sürtünme gibi "
"denklemlerimiz tarafından modellenmeyen herhangi bir şekilde bozulursa, "
"motorun açısal hızı zamanla modelden sapacaktır. Bununla mücadele etmek "
"için, motora bir geri besleme kontrolörü kullanarak düzeltici komutlar "
"verebiliriz."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:125
msgid ""
"A PID controller is a form of feedback control. State-space control often "
"uses the following :term:`control law`, where :math:`\\mathbf{K}` is some "
"controller :term:`gain` matrix, :math:`\\mathbf{r}` is the :term:`reference`"
" state, and :math:`\\mathbf{x}` is the current state in state-space. The "
"difference between these two vectors, :math:`\\mathbf{r-x}`, is the "
":term:`error`."
msgstr ""
"PID kontrolörü, bir geri besleme kontrolü biçimidir. Durum uzayı kontrolü "
"genellikle şunları kullanır :term:`control law`, burada :math:`\\mathbf{K}` "
"bazı kontrolcü :term:`gain` matrisi, :math:`\\mathbf{r}` :term:`reference` "
"durumu ve :matematik:`\\mathbf{x}` durum uzayındaki mevcut durumdur. Bu iki "
"vektör arasındaki fark :math:`\\mathbf{r-x}`, :term:`error`dır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:127
msgid ""
"\\mathbf{u} = \\mathbf{K(r - x)}\n"
"\n"
msgstr ""
"\\mathbf{u} = \\mathbf{K(r - x)}\n"
"\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:130
msgid ""
"This :term:`control law` is a proportional controller for each state of our "
"system. Proportional controllers create software-defined springs that pull "
"our system's state toward our reference state in state-space. In the case "
"that the system being controlled has position and velocity states, the "
":term:`control law` above will behave as a PD controller, which also tries "
"to drive position and velocity error to zero."
msgstr ""
"Bu :term:`control law`, sistemimizin her durumu için oransal  bir "
"denetleyicidir. Oransal denetleyiciler, sistemimizin durumunu durum "
"uzayındaki referans durumuna çeken yazılım tanımlı yaylar oluşturur. Kontrol"
" edilen sistemin konum ve hız durumlarına sahip olması durumunda, yukarıdaki"
" :terim:`control law`, aynı zamanda konumu ve hız hatasını sıfıra çekmeye "
"çalışan bir PD kontrolörü gibi davranacaktır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:132
msgid ""
"Let's show an example of this control law in action. We'll use the pendulum "
"system from above, where the swinging pendulum circled the origin in state-"
"space. The case where :math:`\\mathbf{K}` is the zero matrix (a matrix with "
"all zeros) would be like picking P and D gains of zero -- no control "
":term:`input` would be applied, and the phase portrait would look identical "
"to the one above."
msgstr ""
"Bu kontrol yasasının uygulamada bir örneğini gösterelim. Sarkaç sistemini "
"yukarıdan kullanacağız, burada sallanan sarkaç durum uzayında orijini daire "
"içine aldı. :math:`\\mathbf{K}` sıfır matrisinin (tümü sıfır olan bir "
"matris), sıfırın P ve D kazançlarını toplama gibi olacağı durum -- kontrol "
"yok :term:`girdi` uygulanabilir ve aşama portresi yukarıdakiyle aynı "
"görünecektir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:134
msgid ""
"To add some feedback, we arbitrarily pick a :math:`\\mathbf{K}` of [2, 2], "
"where our :term:`input` to the pendulum is angular acceleration. This K "
"would mean that for every radian of position :term:`error`, the angular "
"acceleration would be 2 radians per second squared; similarly, we accelerate"
" by 2 radians per second squared for every radian per second of "
":term:`error`. Try following an arrow from somewhere in state-space inwards "
"-- no matter the initial conditions, the state will settle at the "
":term:`reference` rather than circle endlessly with pure feedforward."
msgstr ""
"Geri bildirim eklemek için, rasgele olarak bir :math:`\\mathbf{K}` of [2, 2]"
" seçiyoruz; burada sarkaç için bizim :term:`input` açısal ivmedir. Bu K, her"
" bir konumun radyan :term:`hata` için, açısal ivmenin saniyede 2 radyan kare"
" olacağı anlamına gelir; benzer şekilde, :terim:`hata` nın her saniyesinde "
"her radyan için saniyede 2 radyan kare hızlanırız. Durum uzayında bir yerden"
" içeriye doğru bir oku takip etmeyi deneyin - başlangıçtaki koşullar ne "
"olursa olsun, durum, saf ileri beslemeyle sonsuza kadar daire çizmek yerine "
":term:`referans` a yerleşecektir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:139
msgid ""
"But how can we choose an optimal :term:`gain` matrix K for our system? While"
" we can manually choose :term:`gains <gain>` and simulate the system "
"response or tune it on-robot like a PID controller, modern control theory "
"has a better answer: the Linear-Quadratic Regulator (LQR)."
msgstr ""
"Ancak, sistemimiz için bir optimal :terim:`kazanç` matrisi K'yi nasıl "
"seçebiliriz? Manuel olarak şu seçimi yapabilsek de :terim:`<gain> kazanır` "
"ve sistem yanıtını simüle edebilir veya bir PID kontrolörü gibi robot "
"üzerinde ayarlayabilirken, modern kontrol teorisinin daha iyi bir cevabı var"
" :Linear-Quadratic Regulator (LQR)."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:142
msgid "The Linear-Quadratic Regulator"
msgstr "Linear-Quadratic Regulator / Doğrusal-Kuadratik Düzenleyici"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:144
msgid ""
"Because model-based control means that we can predict the future states of a"
" system given an initial condition and future control inputs, we can pick a "
"mathematically optimal :term:`gain` matrix :math:`\\mathbf{K}`. To do this, "
"we first have to define what a \"good\" or \"bad\" :math:`\\mathbf{K}` would"
" look like. We do this by summing the square of error and control input over"
" time, which gives us a number representing how \"bad\" our control law will"
" be. If we minimize this sum, we will have arrived at the optimal control "
"law."
msgstr ""
"Model tabanlı kontrol, bir başlangıç koşulu ve gelecekteki kontrol girdileri"
" verilen bir sistemin gelecekteki durumlarını tahmin edebileceğimiz anlamına"
" geldiğinden, matematiksel olarak en uygun olanı seçebiliriz :term:`gain` "
"matrix :math:`\\mathbf{K}`. Bunu yapmak için, önce \"iyi\" veya \"kötü\" nün"
" neye benzeyeceğini tanımlamalıyız :math:`\\mathbf{K}` . Bunu, hata karesini"
" ve zaman içindeki kontrol girdisini toplayarak yaparız, bu da bize kontrol "
"yasamızın ne kadar \"kötü\" olacağını gösteren bir sayı verir. Bu miktarı en"
" aza indirirsek, optimal kontrol yasasına ulaşmış olacağız."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:147
msgid "LQR: Definition"
msgstr "LQR: Tanım"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:156
msgid ""
"LQR design's :math:`\\mathbf{Q}` and :math:`\\mathbf{R}` matrices don't need"
" discretization, but the :math:`\\mathbf{K}` calculated for continuous-time "
"and discrete time :term:`systems <system>` will be different."
msgstr ""
"LQR tasarımının  :math:`\\mathbf{Q}` ve :math:`\\mathbf{R}`  matrisleri "
"ayrıklaştırmaya ihtiyaç duymaz, ancak :math:`\\mathbf{K}` sürekli zaman ve "
"ayrık zaman için hesaplanır :term:`systems <sisemleri>` farklı olacaktır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:159
msgid "LQR: tuning"
msgstr "LQR: ayarlama"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:161
msgid ""
"Like PID controllers can be tuned by adjusting their gains, we also want to "
"change how our control law balances our error and input. For example, a "
"spaceship might want to minimize the fuel it expends to reach a given "
"reference, while a high-speed robotic arm might need to react quickly to "
"disturbances."
msgstr ""
"PID kontrolörlerinin kazançlarını değiştirilerek ayarlanabildiği gibi, "
"kontrol yasamızın hatamızı ve girdimizi nasıl dengelediğini de değiştirmek "
"istiyoruz. Örneğin, bir uzay gemisi belirli bir referansa ulaşmak için "
"harcadığı yakıtı en aza indirmek isteyebilirken, yüksek hızlı bir robotik "
"kolun bozulmalara hızlı tepki vermesi gerekebilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:163
msgid ""
"We can weight error and control effort in our LQR with :math:`\\mathbf{Q}` "
"and :math:`\\mathbf{R}` matrices. In our cost function (which describes how "
"\"bad\" our control law will perform), :math:`\\mathbf{Q}` and "
":math:`\\mathbf{R}` weight our error and control input relative to each "
"other. In the spaceship example from above, we might use a "
":math:`\\mathbf{Q}` with relatively small numbers to show that we don't want"
" to highly penalize error, while our :math:`\\mathbf{R}` might be large to "
"show that expending fuel is undesirable."
msgstr ""
"LQR'mizdeki hata ve kontrol çabasını :math:`\\mathbf{Q}`  ve "
":math:`\\mathbf{R}` matrisleriyle ağırlıklandırabiliriz. Maliyet "
"fonksiyonumuzda (kontrol yasamızın ne kadar \"kötü\" performans "
"göstereceğini açıklar), :math:`\\mathbf{Q}`  ve :math:`\\mathbf{R}`, "
"hatamızı ve kontrol girdimizi birbirine göre ağırlıklandırır. Yukarıdaki "
"uzay gemisi örneğinde, hatayı çok fazla cezalandırmak istemediğimizi "
"göstermek için nispeten küçük sayılarla :math:`\\ mathbf{Q}` kullanabiliriz,"
" oysa :math:`\\mathbf{R}` yakıt harcamanın istenmeyen olduğunu göstermek "
"için büyük olabilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:165
msgid ""
"With WPILib, the LQR class takes a vector of desired maximum state "
"excursions and control efforts and converts them internally to full Q and R "
"matrices with Bryson's rule. We often use lowercase :math:`\\mathbf{q}` and "
":math:`\\mathbf{r}` to refer to these vectors, and :math:`\\mathbf{Q}` and "
":math:`\\mathbf{R}` to refer to the matrices."
msgstr ""
"WPILib ile LQR sınıfı, istenen maksimum durum sapmalarını ve kontrol "
"çabalarının bir vektörünü alır ve bunları dahili olarak Bryson kuralıyla tam"
" Q ve R matrislerine dönüştürür. Bu vektörlere atıfta bulunmak için "
"genellikle küçük harf :math:`\\mathbf{q}` ve :math:`\\mathbf{r}` kullanır "
"ayrıca matrisleri belirtmek için  :math:`\\mathbf{Q}` ve :math:`\\mathbf{R}`"
" kullanır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:171
msgid ""
"For example, we might use the following Q and R for an elevator system with "
"position and velocity states."
msgstr ""
"Örneğin, konum ve hız durumlarına sahip bir asansör sistemi için aşağıdaki Q"
" ve R'yi kullanabiliriz."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:222
msgid "LQR: example application"
msgstr "LQR: örnek uygulama"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:229
msgid ""
"We arbitrarily choose a desired state excursion (maximum error) of :math:`q "
"= [0.1\\ \\text{rad/sec}]`, and an :math:`\\mathbf{r}` of :math:`[12\\ "
"\\text{volts}]`. After discretization with a timestep of 20ms, we find a "
":term:`gain` of :math:`\\mathbf{K} = ~81`. This K :term:`gain` acts as the "
"proportional component of a PID loop on flywheel's velocity."
msgstr ""
":math:`[12\\ \\text{volts}]` nın :math:`q = [0.1\\ \\text{rad/sec}]`, ve "
":math:`\\mathbf{r}` si ile İstenilen bir durum sapmasını (maksimum hata) "
"keyfi olarak seçeriz. 20 ms'lik bir zaman adımı ile ayrıklaştırmadan sonra, "
":math:`\\mathbf{K} = ~81` nın bir :term:`gain` kazancını buluruz. Bu K "
":term:`gain`  volanın hızı üzerindeki bir PID döngüsünün orantılı bileşeni "
"olarak işlev görür."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:233
msgid ""
"The following graph shows the flywheel's angular velocity and applied "
"voltage over time with two different :term:`gain`\\s. We can see how a "
"higher :term:`gain` will make the system reach the reference more quickly "
"(at t = 0.8 seconds), while keeping our motor saturated at 12V for longer. "
"This is exactly the same as increasing the P gain of a PID controller by a "
"factor of ~8x."
msgstr ""
"Aşağıdaki grafik, volanın açısal hızını ve zaman içinde uygulanan voltajı "
"iki farklı :term:`gain`\\ ile gösterir. Daha yüksek bir :term:`gain` ın "
"sistemin referansa daha hızlı (t = 0,8 saniyede) ulaşmasını sağlarken, "
"motorumuzu daha uzun süre 12V'de doygun tutacağını görebiliriz. Bu, bir PID "
"kontrol cihazının P kazancını ~8x faktörü ile artırmakla tamamen aynıdır."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:239
msgid "LQR and Measurement Latency Compensation"
msgstr "LQR ve Ölçüm Gecikme Telafisi"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:241
msgid ""
"Oftentimes, our sensors have a delay associated with their measurements. For"
" example the SPARK MAX motor controller over CAN can have up to 30ms of "
"delay associated with velocity measurements."
msgstr ""
"Çoğu zaman, sensörlerimizin ölçümleriyle ilişkili bir gecikmeye sahiptir. "
"Örneğin CAN üzerinden SPARK MAX motor kontrolörü, hız ölçümleriyle ilişkili "
"30 ms'ye kadar gecikmeye sahip olabilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:243
msgid ""
"This lag means that our feedback controller will be generating voltage "
"commands based on state estimates from the past. This often has the effect "
"of introducing instability and oscillations into our system, as shown in the"
" graph below."
msgstr ""
"Bu gecikme, geri bildirim denetleyicimizin geçmişteki durum tahminlerine "
"göre voltaj komutları oluşturacağı anlamına gelir. Bu, genellikle aşağıdaki "
"grafikte gösterildiği gibi sistemimize kararsızlık ve salınımlar getirme "
"etkisine sahiptir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:247
msgid ""
"\\mathbf{K_{compensated}} = \\mathbf{K} \\cdot \\left(\\mathbf{A} - \\mathbf{BK}\\right)^{\\text{delay} / dt}\n"
"\n"
msgstr ""
"\\mathbf{K_{compensated}} = \\mathbf{K} \\cdot \\left(\\mathbf{A} - \\mathbf{BK}\\right)^{\\text{delay} / dt}\n"
"\n"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:250
msgid ""
"Multiplying :math:`\\mathbf{K}` by :math:`\\mathbf{A} - \\mathbf{BK}` "
"essentially advances the gains by one timestep. In this case, we multiply by"
" :math:`\\left(\\mathbf{A} - \\mathbf{BK}\\right)^{\\text{delay} / dt}` to "
"advance the gains by measurement's delay."
msgstr ""
":math:`\\mathbf{A} - \\mathbf{BK}` ile :math:`\\mathbf{K}` çarpmak temelde "
"kazançları bir zaman adımı ilerletir. Bu durumda, kazançları ölçüm "
"gecikmesiyle ilerletmek için :math:`\\left(\\mathbf{A} - "
"\\mathbf{BK}\\right)^{\\text{delay} / dt}` ile çarpıyoruz."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:255
msgid ""
"This can have the effect of reducing :math:`\\mathbf{K}` to zero, "
"effectively disabling feedback control."
msgstr ""
"Bu, :math:`\\mathbf{K}` 'yi sıfıra düşürerek geribildirim kontrolünü etkin "
"bir şekilde devre dışı bırakma etkisine sahip olabilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:257
msgid ""
"The SPARK MAX motor controller uses a 40-tap FIR filter with a delay of "
"19.5ms, and status frames are by default sent every 20ms."
msgstr ""
"SPARK MAX motor kontrolörü, 19,5 ms gecikmeli 40-kademe FIR filtresi "
"kullanır ve durum çerçeveleri varsayılan olarak her 20 ms'de bir gönderilir."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:259
msgid ""
"The code below shows how to adjust the LQR controller's K gain for sensor "
"input delays:"
msgstr ""
"Aşağıdaki kod, sensör giriş gecikmeleri için LQR kontrol cihazının K "
"kazancının nasıl ayarlanacağını gösterir:"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:284
msgid "Linearization"
msgstr "Doğrusallaştırma"

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:286
msgid ""
"Linearization is a tool used to approximate nonlinear functions and state-"
"space systems using linear ones. In two-dimensional space, linear functions "
"are straight lines while nonlinear functions curve. A common example of a "
"nonlinear function and its corresponding linear approximation is "
":math:`y=\\sin{x}`. This function can be approximated by :math:`y=x` near "
"zero. This approximation is accurate while near :math:`x=0`, but looses "
"accuracy as we stray further from the linearization point. For example, the "
"approximation :math:`\\sin{x} \\approx x` is accurate to within 0.02 within "
"0.5 radians of :math:`y = 0`, but quickly loses accuracy past that. In the "
"following picture, we see :math:`y =\\sin{x}`, :math:`y=x` and the "
"difference between the approximation and the true value of :math:`\\sin{x}` "
"at :math:`x`."
msgstr ""
"Doğrusallaştırma, doğrusal olmayan fonksiyonları ve durum uzay sistemlerini "
"doğrusal olanları kullanarak kestirmek için kullanılan bir araçtır. İki "
"boyutlu uzayda doğrusal fonksiyonlar düz çizgilerdir, doğrusal olmayan "
"fonksiyonlar ise eğri olur. Doğrusal olmayan bir fonksiyonun yaygın bir "
"örneği ve buna karşılık gelen doğrusal yaklaşımı şöyledir "
":math:`y=\\sin{x}`. Bu fonksiyon şu şekilde yaklaştırılabilir :math:`y = x` "
"sıfıra yakın. Bu yaklaşım, :math:`x=0` a yakın iken doğrudur, ancak "
"doğrusallaştırma noktasından uzaklaştıkça doğruluğu kaybeder. Örneğin, "
":math:`\\sin{x} \\approx x` yaklaşımı :math:`y = 0`  0,5 radyan içinde 0,02 "
"aralığında doğrudur, ancak bundan sonra doğruluğu hızla kaybeder. Aşağıdaki "
"resimde şunu görüyoruz :math:`y =\\sin{x}`, :math:`y=x`  ve yaklaşık ile "
"gerçek değeri arasındaki fark :math:`\\sin{x}` at :math:`x`."

#: ../../frc-docs/source/docs/software/advanced-controls/state-space/state-space-intro.rst:291
msgid ""
"We can also linearize state-space systems with nonlinear :term:`dynamics`. "
"We do this by picking a point :math:`\\mathbf{x}` in state-space and using "
"this as the input to our nonlinear functions. Like in the above example, "
"this works well for states near the point about which the system was "
"linearized, but can quickly diverge further from that state."
msgstr ""
"Doğrusal olmayan :term:`dynamics\" ile durum uzay sistemlerini de "
"doğrusallaştırabiliriz. Bunu durum uzayında bir nokta :math:`\\mathbf{x}` "
"seçerek ve bunu doğrusal olmayan fonksiyonlarımızın girdisi olarak "
"kullanarak yapıyoruz. Yukarıdaki örnekte olduğu gibi, bu, sistemin "
"doğrusallaştırıldığı noktaya yakın durumlar için iyi çalışır, ancak bu "
"durumdan hızla uzaklaşabilir."
